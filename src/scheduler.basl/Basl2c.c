/*
*         OpenPBS (Portable Batch System) v2.3 Software License
* 
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
* 
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
* 
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
* 
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
* 
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
* 
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
* 
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
* 
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
* 
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
* 
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
* 
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information 
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
* 
* 7. DISCLAIMER OF WARRANTY
* 
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
* 
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/

#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>
#include <string.h>
#include <math.h>
#include "Parser.h"
#include "Lexer.h"
#include "SymTab.h"
#include "Semantic.h"
#include "CodeGen.h"

static char ident[] = "@(#) $RCSfile$ $Revision$";
int	linenum = 1;	/* manipulated by both Parser and Lexer */
jmp_buf begin;		/* where to return from in case of a FPE error */

extern FILE *ParserFpOut;
extern FILE *LexerFpOut;
extern FILE *NodeFpOut;
extern FILE *ListFpOut;
extern FILE *SymTabFpOut;
extern FILE *SemanticFpOut;
extern FILE *CodeGenFpOut;
extern FILE *CodeGenFpImedCode;
extern FILE *yyin;
extern FILE *yyout;

static void loadUserAccessibleAssistFuncs(void)
{
	Np np;	

	/* Server AllServersLocalHostGet() */
	np = NodeNew("AllServersLocalHostGet", SERVERTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	
	/* Set Server AllServersGet() {} */
	np = NodeNew("AllServersGet", SERVERSETTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	/* String ServerInetAddrGet("Server s) {} */
	np = NodeNew("ServerInetAddrGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	
	/* String ServerDefQueGet("Server s) {} */
	np = NodeNew("ServerDefQueGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	
	/* Int ServerStateGet("Server s) {} */
	np = NodeNew("ServerStateGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	
	/* Int ServerMaxRunJobsGet("Server s) {} */
	np = NodeNew("ServerMaxRunJobsGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	
	/* Int ServerMaxRunJobsPerUserGet("Server s) {} */
	np = NodeNew("ServerMaxRunJobsPerUserGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int ServerMaxRunJobsPerGroupGet("Server s) {} */
	np = NodeNew("ServerMaxRunJobsPerGroupGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Set Que	ServerQueuesGet("Server s) {} */
	np = NodeNew("ServerQueuesGet", QUESETTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Set Job	ServerJobsGet("Server s) {} */
	np = NodeNew("ServerJobsGet", JOBSETTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerIntResAvailGet(Server s, String name) {} */
	np = NodeNew("ServerIntResAvailGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Size	ServerSizeResAvailGet(Server s, String name) {} */
	np = NodeNew("ServerSizeResAvailGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* String ServerStringResAvailGet(Server s, String name) {} */
	np = NodeNew("ServerStringResAvailGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerIntResAssignGet(Server s, String name) {} */
	np = NodeNew("ServerIntResAssignGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Size	ServerSizeResAssignGet(Server s, String name) {} */
	np = NodeNew("ServerSizeResAssignGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* String ServerStringResAssignGet(Server s, String name) {} */
	np = NodeNew("ServerStringResAssignGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesGet(Server s) {} */
	np = NodeNew("ServerNodesGet", CNODESETTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesQuery(Server s, String spec) {} */
	np = NodeNew("ServerNodesQuery", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("spec", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesReserve(Server s, String spec, Int resId) {} */
	np = NodeNew("ServerNodesReserve", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("spec", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("resId", INTTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesRelease(Server s, Int resId) {} */
	np = NodeNew("ServerNodesRelease", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("resId", INTTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesNumAvailGet(Server s) {} */
	np = NodeNew("ServerNodesNumAvailGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesNumAllocGet(Server s) {} */
	np = NodeNew("ServerNodesNumAllocGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesNumRsvdGet(Server s) {} */
	np = NodeNew("ServerNodesNumRsvdGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	ServerNodesNumDownGet(Server s) {} */
	np = NodeNew("ServerNodesNumDownGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("s", SERVERTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Set Cnode AllNodesGet() {} */
	np = NodeNew("AllNodesGet", CNODESETTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	/* Cnode AllNodesLocalHostGet() {} */
	np = NodeNew("AllNodesLocalHostGet", CNODETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);

	/* String CnodeNameGet("Cnode node) {} */
	np = NodeNew("CNodeNameGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String CnodePropertiesGet("Cnode node) {} */
	np = NodeNew("CNodePropertiesGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String CnodeVendorGet("Cnode node) {} */
	np = NodeNew("CNodeVendorGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	
	/* String CnodeOsGet("Cnode node) {} */
	np = NodeNew("CNodeOsGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeNumCpusGet(Cnode node) {} */
	np = NodeNew("CNodeNumCpusGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int CnodeCpuPercentIdleGet(Cnode node) {} */
	np = NodeNew("CNodeCpuPercentIdleGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int CnodeCpuPercentSysGet(Cnode node) {} */
	np = NodeNew("CNodeCpuPercentSysGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeCpuPercentUserGet(Cnode node) {} */
	np = NodeNew("CNodeCpuPercentUserGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int CnodeCpuPercentGuestGet(Cnode node) {} */
	np = NodeNew("CNodeCpuPercentGuestGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Size  CnodeMemTotalGet( Cnode node, String type ) {} */
	np = NodeNew("CNodeMemTotalGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("type", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size  CnodeMemAvailGet( Cnode node, String type ) {} */
	np = NodeNew("CNodeMemAvailGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("type", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeStateGet( Cnode node ) {} */
	np = NodeNew("CNodeStateGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int CnodeTypeGet( Cnode node ) {} */
	np = NodeNew("CNodeTypeGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeIdletimeGet( Cnode node ) {} */
	np = NodeNew("CNodeIdletimeGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Float CnodeLoadAveGet( Cnode  node ) {} */
	np = NodeNew("CNodeLoadAveGet",  FLOATTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeNetworkBwGet( Cnode node, String type ) {} */
	np = NodeNew("CNodeNetworkBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("type", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeDiskSpaceTotalGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeDiskSpaceTotalGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeDiskSpaceAvailGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeDiskSpaceAvailGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeDiskSpaceReservedGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeDiskSpaceReservedGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeDiskInBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeDiskInBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeDiskOutBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeDiskOutBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeSwapSpaceTotalGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSwapSpaceTotalGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeSwapSpaceAvailGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSwapSpaceAvailGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeSwapInBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSwapInBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeSwapOutBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSwapOutBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeTapeSpaceTotalGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeTapeSpaceTotalGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeTapeSpaceAvailGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeTapeSpaceAvailGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeTapeInBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeTapeInBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeTapeOutBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeTapeOutBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeSrfsSpaceTotalGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSrfsSpaceTotalGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeSrfsSpaceAvailGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSrfsSpaceAvailGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Size CnodeSrfsSpaceReservedGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSrfsSpaceReservedGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeSrfsInBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSrfsInBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeSrfsOutBwGet( Cnode node, String name ) {} */
	np = NodeNew("CNodeSrfsOutBwGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("node", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int CnodeMatchPair( Cnode sys, CNode jreq) {} */
	np = NodeNew("CNodeMatchPair", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("sys", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	np = NodeNew("jreq", CNODETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* String QueNameGet( Que que ) {} */
	np = NodeNew("QueNameGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int QueTypeGet( Que que ) {} */
	np = NodeNew("QueTypeGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int QueNumJobsGet( Que que ) {} */
	np = NodeNew("QueNumJobsGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int QueMaxRunJobsGet( Que que ) {} */
							
	np = NodeNew("QueMaxRunJobsGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int QueMaxRunJobsPerUserGet( Que que ) {} */
	np = NodeNew("QueMaxRunJobsPerUserGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int QueMaxRunJobsPerGroupGet( Que que ) {} */
	np = NodeNew("QueMaxRunJobsPerGroupGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int QuePriorityGet( Que que ) {} */
	np = NodeNew("QuePriorityGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int QueStateGet( Que que ) {} */
	np = NodeNew("QueStateGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);

	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	

	/* Int	QueIntResAvailGet(Que q, String name) {} */
	np = NodeNew("QueIntResAvailGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("q", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Size	QueSizeResAvailGet(Que q, String name) {} */
	np = NodeNew("QueSizeResAvailGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("q", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* String QueStringResAvailGet(Que q, String name) {} */
	np = NodeNew("QueStringResAvailGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("q", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	QueIntResAssignGet(Que q, String name) {} */
	np = NodeNew("QueIntResAssignGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("q", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Size	QueSizeResAssignGet(Que q, String name) {} */
	np = NodeNew("QueSizeResAssignGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("q", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* String QueStringResAssignGet(Que q, String name) {} */
	np = NodeNew("QueStringResAssignGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("q", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Set Job QueJobsGet( Que que ) {} */
	np = NodeNew("QueJobsGet", JOBSETTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);

	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobIdGet( Job job ) {} */
	np = NodeNew("JobIdGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobNameGet( Job job ) {} */
	np = NodeNew("JobNameGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobOwnerNameGet( Job job ) {} */
	np = NodeNew("JobOwnerNameGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobEffectiveUserNameGet( Job job ) {} */
	np = NodeNew("JobEffectiveUserNameGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobEffectiveGroupNameGet( Job job ) {} */
	np = NodeNew("JobEffectiveGroupNameGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int JobStateGet ( Job job ) {} */
	np = NodeNew("JobStateGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int JobPriorityGet( Job job ) {} */
	np = NodeNew("JobPriorityGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int JobRerunFlagGet( Job job ) {} */
	np = NodeNew("JobRerunFlagGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int JobInteractiveFlagGet( Job job ) {} */
	np = NodeNew("JobInteractiveFlagGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* DateTime JobDateTimeCreatedGet( Job job ) {} */
	np = NodeNew("JobDateTimeCreatedGet", DATETIMETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobEmailAddrGet( Job job ) {} */
	np = NodeNew("JobEmailAddrGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobStageinFilesGet( Job job ) {} */
	np = NodeNew("JobStageinFilesGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* String JobStageoutFilesGet( Job job ) {} */
	np = NodeNew("JobStageoutFilesGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
	
	/* Int	JobIntResReqGet(Job j, String name) {} */
	np = NodeNew("JobIntResReqGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("j", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Size	JobSizeResReqGet(Job j, String name) {} */
	np = NodeNew("JobSizeResReqGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("j", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* String JobStringResReqGet(Job j, String name) {} */
	np = NodeNew("JobStringResReqGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("j", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Int	JobIntResUseGet(Job j, String name) {} */
	np = NodeNew("JobIntResUseGet", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("j", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Size	JobSizeResUseGet(Job j, String name) {} */
	np = NodeNew("JobSizeResUseGet", SIZETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("j", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* String JobStringResUseGet(Job j, String name) {} */
	np = NodeNew("JobStringResUseGet", STRINGTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("j", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("name", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());


	/* String JobAction( Job job, Act act, String param ) {} */
	np = NodeNew("JobAction", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("job", JOBTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("act", INTTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("param", STRINGTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* Job QueJobFind( Que que, Fun Int fun, Int cpr, Int value ) */
	/* Job QueJobFind( Que que, Fun String fun, Int cpr, String value ) */
	/* Job QueJobFind( Que que, Fun Date fun, Int cpr, Date value ) */
	/* Job QueJobFind( Que que, Fun Time fun, Int cpr, Time value ) */
	/* Job QueJobFind( Que que, Fun Size fun, Int cpr, Size value ) */

	/* Job QueJobFind( Que que, Fun Int fun, Cpr cpr = {OP_MAX|OP_MIN}) */
	/* Job QueJobFind( Que que, Fun String fun, Cpr cpr = {OP_MAX|OP_MIN}) */
	/* Job QueJobFind( Que que, Fun Date fun, Cpr cpr = {OP_MAX|OP_MIN}) */
	/* Job QueJobFind( Que que, Fun Time fun, Cpr cpr = {OP_MAX|OP_MIN}) */
	/* Job QueJobFind( Que que, Fun Size fun, Cpr cpr = {OP_MAX|OP_MIN}) */

	np = NodeNew("QueJobFind", JOBTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* GENERIC TYPE matches anything */
	np = NodeNew("fun", GENERICTYPE, 0, 0, YES);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("cpr", INTTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("value", GENERICTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* void QueFilter( Que que, Que newq, Fun Int fun, Int cpr, Int value ) */
	/* void QueFilter( Que que, Que newq, Fun String fun, Int cpr, String value ) */
	/* void QueFilter( Que que, Que newq, Fun Date fun, Int cpr, Date value ) */
	/* void QueFilter( Que que, Que newq, Fun Time fun, Int cpr, Time value ) */
	/* void QueFilter( Que que, Que newq, Fun Size fun, Int cpr, Size value ) */

	np = NodeNew("QueFilter", QUETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	np = NodeNew("que", QUETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* GENERIC TYPE matches anything */
	np = NodeNew("fun", GENERICTYPE, 0, 0, YES);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("cpr", INTTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("value", GENERICTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

/*	Int Sort( {SetJob,SetQue,SetServer,SetCNode} col, 
	      {Int,Float,String,DateTime,Size}   keyfunc,
	      {ASC, DESC}			 order
*/		

	np = NodeNew("Sort", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);
	
	/* GENERIC TYPE matches anything */
	np = NodeNew("col", GENERICTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("keyfunc", GENERICTYPE, 0, 0, YES);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	np = NodeNew("order", INTTYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());

	/* DateTime datetimeGet() {} */
	np = NodeNew("datetimeGet", DATETIMETYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);

	/* DateTime datetimeToSecs(DateTime dt) {} */
	np = NodeNew("datetimeToSecs", INTTYPE, 0, 0, YES_INT);
	SymTabInsertFront(np);
	ParserCurrFunPtrPut(np);

	np = NodeNew("dt", DATETIMETYPE, 0, 0, NO);
	SymTabParamLink(ParserCurrFunPtrGet(), np);
	NodeParamCntIncr(ParserCurrFunPtrGet());
}

static void addIncludes(void)
{
	fprintf(CodeGenFpImedCode, "#include <stdio.h>\n");
	fprintf(CodeGenFpImedCode, "#include <unistd.h>\n");
	fprintf(CodeGenFpImedCode, "#include \"portability.h\"\n");
	fprintf(CodeGenFpImedCode, "#include \"af.h\"\n");
	fprintf(CodeGenFpImedCode, "#include \"af_system.h\"\n");
	fprintf(CodeGenFpImedCode, "#include \"af_server.h\"\n");
	fprintf(CodeGenFpImedCode, "#include \"af_cnode.h\"\n");
}

static void addMainSched(void)
{
	fprintf(CodeGenFpImedCode, "main(argc, argv)\n");
	fprintf(CodeGenFpImedCode, "int  argc;\n");
	fprintf(CodeGenFpImedCode, "char *argv[];\n");
	fprintf(CodeGenFpImedCode, "{\n");

        fprintf(CodeGenFpImedCode, "	SystemInit(argc, argv);\n");
        fprintf(CodeGenFpImedCode, "	sched_init();\n");
        fprintf(CodeGenFpImedCode, "	SystemStateRead(sched_main);\n");
	fprintf(CodeGenFpImedCode, "	SystemClose();\n");
	fprintf(CodeGenFpImedCode, "}\n");

/*
  	fprintf(CodeGenFpImedCode, "printf(\"Printing Dynamic Array Table: \\n\");\n");
  	fprintf(CodeGenFpImedCode, "printDynamicArrayTable();\n");
  	fprintf(CodeGenFpImedCode, "printf(\"Printing Varstr Table: \\n\");\n");
  	fprintf(CodeGenFpImedCode,"varstrPrint();\n");
  	fprintf(CodeGenFpImedCode, "printf(\"Printing Malloc Table Table: \\n\");\n");
  	fprintf(CodeGenFpImedCode, "mallocTablePrint();\n");

        fprintf(CodeGenFpImedCode, "		sched_main();\n");
  	fprintf(CodeGenFpImedCode, "printf(\"Printing Dynamic Array Table: \\n\");\n");
  	fprintf(CodeGenFpImedCode, "printDynamicArrayTable();\n");
  	fprintf(CodeGenFpImedCode, "printf(\"Printing Varstr Table: \\n\");\n");
  	fprintf(CodeGenFpImedCode,"varstrPrint();\n");
  	fprintf(CodeGenFpImedCode, "printf(\"Printing Malloc Table Table: \\n\");\n");
  	fprintf(CodeGenFpImedCode, "mallocTablePrint();\n");
	fprintf(CodeGenFpImedCode, "}\n");
*/

}

#define GETOPT_ARGS "dp:l:y:s:g:c:"
main(argc, argv)
int	argc;
char	**argv;
{
	int 		c;
	int		debugflg = 0;
    	int 		errflg=0;
	char		parserDebugFile[80];
	char		lexerDebugFile[80];
	char		symtabDebugFile[80];
	char		semanticDebugFile[80];
	char		codegenDebugFile[80];
	char		cFile[80];
	extern 		char *optarg;
	extern 		int  optind;
	extern		int yyparse();


	LexerFpOut = stdout;
	ParserFpOut = stdout;
	NodeFpOut = stdout;
	ListFpOut = stdout;
	SymTabFpOut = stdout;
	SemanticFpOut = stdout;
	CodeGenFpOut = stdout;

	strcpy(cFile, "pbs_sched.c");
	if( (CodeGenFpImedCode = fopen(cFile, "w")) == NULL ) {
		fprintf(stderr, "Error opening c translation file.\n");
		exit(2);
	}

    	while ((c = getopt(argc, argv, GETOPT_ARGS)) != EOF) {
    		switch (c) {
    		  case 'd':
			debugflg = 1;
        		break;
    		  case 'p':
			strcpy(parserDebugFile, optarg);
			if( (LexerFpOut = fopen(parserDebugFile, "w")) == NULL ) {
				fprintf(stderr, "Error opening lexer debug file.\n");
				exit(2);
			}
        		break;
    		  case 'l':
			strcpy(lexerDebugFile, optarg);
			if( (ParserFpOut = fopen(lexerDebugFile, "w")) == NULL ) {
				fprintf(stderr, "Error opening lexer debug file.\n");
				exit(2);
			}
        		break;
    		  case 'y':
			strcpy(symtabDebugFile, optarg);
			if( (SymTabFpOut = fopen(symtabDebugFile, "w")) == NULL ) {
				fprintf(stderr, "Error opening symtab debug file.\n");
				exit(2);
			}
			NodeFpOut=SymTabFpOut;
			ListFpOut=SymTabFpOut;
        		break;
    		  case 's':
			strcpy(semanticDebugFile, optarg);
			if( (SemanticFpOut = fopen(semanticDebugFile, "w")) == NULL ) {
				fprintf(stderr, "Error opening semantic debug file.\n");
				exit(2);
			}
        		break;
    		  case 'g':
			strcpy(codegenDebugFile, optarg);
			if( (CodeGenFpOut = fopen(codegenDebugFile, "w")) == NULL ) {
				fprintf(stderr, "Error opening codegen debug file.\n");
				exit(2);
			}
        		break;
    		  case 'c':
			strcpy(cFile, optarg);
			fclose(CodeGenFpImedCode);
			if( (CodeGenFpImedCode = fopen(cFile, "w")) == NULL ) {
				fprintf(stderr, "Error opening c translation file.\n");
				exit(2);
			}
        		break;
    		  default :
        		errflg++;
    		}
	}
   
	if(errflg || (optind == argc) ) {
        	static char usage[]="usage: basl2c [-d] \
[-p parserDebugFile] [-l lexerDebugFile] \n\
		[-y symtabDebugFile] [-s semanticDebugFile]   \n\
		[-g codegenDebugFile] [-c cFile] baslFile \n";
        	fprintf(stderr, usage);
        	exit(2);
	}

	if( (yyin = fopen(argv[optind], "r")) == NULL ) {
		fprintf(stderr, "Error opening basl input file file.\n");
		exit(2);
	}
	optind++;

	if( optind != argc ) {
        	static char usage[]="usage: basl2cc [-d] \
		[-p parserDebugFile] [-l lexerDebugFile] \n\
		[-y symtabDebugFile] [-s semanticDebugFile]   \n\
		[-g codegenDebugFile] [-c cFile] [-o executable] baslFile \n";
        	fprintf(stderr, usage);
        	exit(2);
	}

	if( debugflg ) {
		LexerPutDF(1);
		ParserPutDF(1);
		SemanticPutDF(1);
		CodeGenPutDF(1);
		SymTabPutDF(1);
		NodePutDF(1);
		ListPutDF(1);
	} else {
		LexerPutDF(0);
		ParserPutDF(0);
		SemanticPutDF(0);
		CodeGenPutDF(0);
		SymTabPutDF(0);
		NodePutDF(0);
		ListPutDF(0);
	}

	LexerInit();
	ParserInit();
	SymTabInit();
	SemanticInit();
	CodeGenInit();

	setjmp(begin);   /* return here after input error */
	signal(SIGFPE, ParserFpeCatch);  /* redefine default FPE handler */

	addIncludes();
	loadUserAccessibleAssistFuncs();
	while(yyparse());

	SymTabDelete();

	addMainSched();
	fclose(LexerFpOut);
	fclose(ParserFpOut);
	fclose(SymTabFpOut);
	fclose(SemanticFpOut);
	fclose(CodeGenFpOut);
	fclose(CodeGenFpImedCode);

	return(0);
}
