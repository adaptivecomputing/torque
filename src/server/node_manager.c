/*
*         OpenPBS (Portable Batch System) v2.3 Software License
*
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
*
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
*
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
*
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
*
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
*
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
*
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
*
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
*
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
*
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
*
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
*
* 7. DISCLAIMER OF WARRANTY
*
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
*
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/

#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <stdarg.h>
#include <assert.h>
#if defined(NTOHL_NEEDS_ARPA_INET_H) && defined(HAVE_ARPA_INET_H)
#include <arpa/inet.h>
#endif


#include "portability.h"
#include "libpbs.h"
#include "server_limits.h"
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "server.h"
#include "net_connect.h"
#include "batch_request.h"
#include "work_task.h"
#include "svrfunc.h"
#include "pbs_job.h"
#include "log.h"
#include "../lib/Liblog/pbs_log.h"
#include "../lib/Liblog/log_event.h"
#include "pbs_nodes.h"
#include "rpp.h"
#include "dis.h"
#include "dis_init.h"
#include "resmon.h"
#include "mcom.h"
#include "utils.h"
#include "u_tree.h"
#include "threadpool.h"
#include "issue_request.h" /* issue_Drequest */
#include "node_func.h" /* find_nodebyname */
#include "../lib/Libutils/u_lock_ctl.h" /* lock_node, unlock_node */
#include "../lib/Libnet/lib_net.h" /* socket_read_flush */
#include "svr_func.h" /* get_svr_attr_* */

#define IS_VALID_STR(STR)  (((STR) != NULL) && ((STR)[0] != '\0'))

extern int LOGLEVEL;

extern int allow_any_mom;

#if !defined(H_ERRNO_DECLARED) && !defined(_AIX)
extern int h_errno;
#endif

int   svr_totnodes = 0; /* total number nodes defined       */
int   svr_clnodes  = 0; /* number of cluster nodes     */
int   svr_tsnodes  = 0; /* number of time shared nodes     */
int   svr_chngNodesfile = 0; /* 1 signals want nodes file update */
int   gpu_mode_rqstd = -1;  /* default gpu mode requested */
#ifdef NVIDIA_GPUS
int   gpu_err_reset = FALSE;    /* was a gpu errcount reset requested */
#endif  /* NVIDIA_GPUS */
/* on server shutdown, (qmgr mods)  */

all_nodes allnodes;

static int  exclusive;  /* node allocation type */

static int       num_addrnote_tasks = 0; /* number of outstanding send_cluster_addrs tasks */
pthread_mutex_t *addrnote_mutex = NULL;

extern int  server_init_type;
extern int  has_nodes;

#ifdef NVIDIA_GPUS
extern int create_a_gpusubnode(struct pbsnode *);
#endif  /* NVIDIA_GPUS */

extern int ctnodes(char *);
extern char *path_home;
extern char *path_nodes;
extern char *path_nodes_new;
extern char *path_nodestate;
extern char *path_nodenote;
extern char *path_nodenote_new;
extern unsigned int pbs_mom_port;
extern char  server_name[];

extern struct server server;
extern tlist_head svr_newnodes;
extern attribute_def  node_attr_def[];   /* node attributes defs */
extern int            SvrNodeCt;
extern hello_container hellos;

extern int multi_mom;

#define SKIP_NONE 0
#define SKIP_EXCLUSIVE 1
#define SKIP_ANYINUSE 2
#define SKIP_NONE_REUSE 3

#ifndef MAX_BM
#define MAX_BM   64
#endif

int hasprop(struct pbsnode *, struct prop *);
int add_cluster_addrs(int,struct pbsnode *);
int is_compose(int, int);
int add_job_to_node(struct pbsnode *,struct pbssubn *,short,job *,int);
int node_satisfies_request(struct pbsnode *,char *);
int reserve_node(struct pbsnode *,short,job *,char *,struct howl **);
int build_host_list(struct howl **,struct pbssubn *,struct pbsnode *);
int procs_available(int proc_ct);
void check_nodes(struct work_task *);
#ifdef NVIDIA_GPUS
int gpu_entry_by_id(struct pbsnode *,char *, int);
#endif  /* NVIDIA_GPUS */
job *get_job_from_jobinfo(struct jobinfo *,struct pbsnode *);

/* marks a stream as finished being serviced */
pthread_mutex_t *node_state_mutex = NULL;



/**
**      Modified by Tom Proett <proett@nas.nasa.gov> for PBS.
*/

/* tree *ipaddrs = NULL; */ /* tree of ip addrs */
AvlTree ipaddrs = NULL;
/* tree *streams = NULL; */ /* tree of stream numbers */
AvlTree streams = NULL;


/**
 * specialized version of tfind for looking in the ipadders tree
 * @param key - the node we are searching for
 * @return a pointer to the pbsnode
*/

struct pbsnode *tfind_addr(

  const u_long  key,
  uint16_t      port,
  job          *pjob)

  {
  struct pbsnode *pn = AVL_find(key,port,ipaddrs);

  if (pn == NULL)
    return(NULL);

  lock_node(pn, __func__, "pn", LOGLEVEL);

  if (pn->num_node_boards == 0)
    return(pn);
  else
    {
    char *dash = NULL;
    char *plus = NULL;
    char *tmp = pjob->ji_wattr[JOB_ATR_exec_host].at_val.at_str;

    struct pbsnode *numa = NULL;

    int index;

    plus = strchr(tmp,'+');

    if (plus != NULL)
      *plus = '\0';

    while ((tmp = strchr(tmp,'-')) != NULL)
      {
      dash = tmp;
      tmp++;
      }

    if (dash == NULL)
      {
      /* node has numa nodes but no dashes in exec host?? */
      log_err(-1, __func__, "Numa node but there's no dash in exec_host?");

      return(pn);
      }

    index = atoi(dash+1);

    numa = AVL_find(index, pn->nd_mom_port, pn->node_boards);

    unlock_node(pn, __func__, "pn->numa", LOGLEVEL);
    lock_node(numa, __func__, "numa", LOGLEVEL);

    if (plus != NULL)
      *plus = '+';

    return(numa);
    }
  } /* END tfind_addr() */



/* update_node_state - central location for updating node state */
/* NOTE:  called each time a node is marked down, each time a MOM reports node  */
/*        status, and when pbs_server sends hello/cluster_addrs */

void update_node_state(

  struct pbsnode *np,         /* I (modified) */
  int             newstate)   /* I (one of INUSE_*) */

  {
  char           *id = "update_node_state";
  char            log_buf[LOCAL_LOG_BUF_SIZE];

  struct pbssubn *sp;
#ifdef ALT_CLSTR_ADDR
  int             ret;
  int             send_addrs = FALSE;
#endif

  /*
   * LOGLEVEL >= 4 logs all state changes
   *          >= 2 logs down->(busy|free) changes
   *          (busy|free)->down changes are always logged
   */

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buf, "adjusting state for node %s - state=%d, newstate=%d",
      (np->nd_name != NULL) ? np->nd_name : "NULL",
      np->nd_state,
      newstate);

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
    }

  log_buf[0] = '\0';

#ifdef ALT_CLSTR_ADDR
  /*
   *  If coming out of DOWN or UNKNOWN states
   *  then we want to send IS_CLUSTER_ADDRS message
   */

  if ((np->nd_state & INUSE_DOWN) ||
      (np->nd_state & INUSE_UNKNOWN))
    {
    if (!(newstate & INUSE_DOWN))
      {
      send_addrs = TRUE;
      }
    }

#endif

  if (newstate & INUSE_DOWN)
    {
    if (!(np->nd_state & INUSE_DOWN))
      {
      sprintf(log_buf, "node %s marked down",
        (np->nd_name != NULL) ? np->nd_name : "NULL");

      np->nd_state |= INUSE_DOWN;
      np->nd_state &= ~INUSE_UNKNOWN;

      /* mark all subnodes down */

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        sp->inuse |= INUSE_DOWN;
        }
      }

    /* ignoring the obvious possibility of a "down,busy" node */
    }  /* END if (newstate & INUSE_DOWN) */
  else if (newstate & INUSE_BUSY)
    {
    if ((!(np->nd_state & INUSE_BUSY) && (LOGLEVEL >= 4)) ||
        ((np->nd_state & INUSE_DOWN) && (LOGLEVEL >= 2)))
      {
      sprintf(log_buf, "node %s marked busy",
        (np->nd_name != NULL) ? np->nd_name : "NULL");
      }

    np->nd_state |= INUSE_BUSY;

    np->nd_state &= ~INUSE_UNKNOWN;

    if (np->nd_state & INUSE_DOWN)
      {
      np->nd_state &= ~INUSE_DOWN;

      /* clear down on all subnodes */

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        sp->inuse &= ~INUSE_DOWN;
        }
      }
    }  /* END else if (newstate & INUSE_BUSY) */
  else if (newstate == INUSE_FREE)
    {
    if (((np->nd_state & INUSE_DOWN) && (LOGLEVEL >= 2)) ||
        ((np->nd_state & INUSE_BUSY) && (LOGLEVEL >= 4)))
      {
      sprintf(log_buf, "node %s marked free",
        (np->nd_name != NULL) ? np->nd_name : "NULL");
      }

    np->nd_state &= ~INUSE_BUSY;

    np->nd_state &= ~INUSE_UNKNOWN;

#ifdef BROKENVNODECHECKS

    if ((np->nd_state & INUSE_JOB) ||
        (np->nd_state & INUSE_JOBSHARE) ||
        (np->nd_nsn != np->nd_nsnfree))
      {
      int snjcount;   /* total number of jobs assigned to nodes */
      int snjacount;  /* number of subnodes with job array associated with them */

      int nsn_free;
      int SNIsAllocated;  /* boolean */

      struct jobinfo *jp;

      struct jobinfo *jpprev;

      char   tmpLine[1024];

      /* count jobs on all subnodes */

      snjcount = 0;
      snjacount = 0;

      /* initially set free subnode count to config subnode count */

      nsn_free = np->nd_nsn;

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        if (sp->jobs != NULL)
          {
          SNIsAllocated = 0;  /* mark subnode allocated only after job detected */

          snjacount++;

          sp->inuse &= ~(INUSE_JOB | INUSE_JOBSHARE);

          /* look for and remove duplicate job entries in subnode job list */

          jpprev = NULL;

          for (jp = sp->jobs;jp != NULL;jp = jp->next)
            {
            if (jp->job != NULL)
              {
              if ((jp->job->ji_qs.ji_state != JOB_STATE_RUNNING) ||
                  (jp->job->ji_qs.ji_substate == JOB_SUBSTATE_SUSPEND) ||
                  (jp->job->ji_wattr[JOB_ATR_state].at_val.at_char == 'S'))
                {
                /* only count suspended and running jobs */

                continue;
                }

              snjcount++;

              if (SNIsAllocated == 0)
                {
                SNIsAllocated = 1;

                nsn_free--;
                }
              }

            if ((jpprev != NULL) && (jpprev->job == jp->job))
              {
              /* duplicate job entry detected */
              sprintf(tmpLine, "ALERT:  duplicate entry for job '%s' detected on node %s (clearing entry)",
                (jp->job != NULL) ? jp->job->ji_qs.ji_jobid : "???",
                np->nd_name);

              log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, tmpLine);

              jpprev->next = jp->next;

              free(jp);

              break;
              }

            jpprev = jp;
            }  /* END for (jp) */
          }    /* END if (sp->jobs != NULL) */
        }      /* END for (sp) */

      if (snjcount == 0)
        {
        /* node has no jobs but is in allocated state - free subnodes */

        np->nd_nsnfree = np->nd_nsn;

        sprintf(log_buf, "job allocation released on node %s - node marked free",
          (np->nd_name != NULL) ? np->nd_name : "NULL");

        if (snjacount > 0)
          {
          strcat(log_buf, " - subnode job array is corrupt");
          }

        np->nd_state &= ~(INUSE_JOB | INUSE_JOBSHARE);
        }
      else
        {
        if (np->nd_nsnfree != nsn_free)
          {
          sprintf(log_buf, "subnode allocation adjusted on node %s (%d -> %d)",
            (np->nd_name != NULL) ? np->nd_name : "NULL",
            np->nd_nsnfree,
            nsn_free);

          np->nd_nsnfree = nsn_free;

          /* what is the exact meaning of JOBSHARE? */

          np->nd_state &= ~INUSE_JOBSHARE;
          }
        else
          {
          /* subnode availability values are correct */

          if (LOGLEVEL >= 7)
            {
            sprintf(log_buf, "subnode allocation correct on node %s (%d free, %d configured)",
              (np->nd_name != NULL) ? np->nd_name : "NULL",
              np->nd_nsnfree,
              np->nd_nsn);
            }
          }

        if (np->nd_nsnfree > 0)
          {
          /* if any sub-nodes are free, job cannot be in job-exclusive */

          np->nd_state &= ~INUSE_JOB;

          if (LOGLEVEL >= 3)
            {
            if (log_buf[0] == '\0')
              sprintf(log_buf,
                "unset job-exclusive state for node %s in state %d (%d free, %d configured)",
                (np->nd_name != NULL) ? np->nd_name : "NULL",
                np->nd_state,
                np->nd_nsnfree,
                np->nd_nsn);
            else
              strcat(log_buf, "(unset job-exclusive state)");
            }
          }
        }    /* END else (snjcount == 0) */
      }      /* END if ((np->nd_state & INUSE_JOB) || ...) */
    else
      {
      /* skipping subnode allocation check */

      if (LOGLEVEL >= 7)
        {
        sprintf(log_buf,
          "skipping subnode allocation test for node %s in state %d (%d free, %d configured)\n",
          (np->nd_name != NULL) ? np->nd_name : "NULL",
          np->nd_state,
          np->nd_nsnfree,
          np->nd_nsn);
        }
      }

#endif /* BROKENVNODECHECKS */

    if (np->nd_state & INUSE_DOWN)
      {
      np->nd_state &= ~INUSE_DOWN;

      /* clear down on all subnodes */

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        sp->inuse &= ~INUSE_DOWN;
        }
      }
    }    /* END else if (newstate == INUSE_FREE) */

  if (newstate & INUSE_UNKNOWN)
    {
    np->nd_state |= INUSE_UNKNOWN;
    }

  if ((LOGLEVEL >= 2) && (log_buf[0] != '\0'))
    {
    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
    }

  return;
  }  /* END update_node_state() */





int check_node_for_job(

  struct pbsnode *pnode,
  char           *jobid)

  {
  struct pbssubn *np;
  struct jobinfo *jp;

  /* just check each subnode for the job */
  for (np = pnode->nd_psn;np != NULL;np = np->next)
    {
    /* for each jobinfo on subnode on node ... */
    for (jp = np->jobs;jp != NULL;jp = jp->next)
      {
      if (jp->jobid != NULL)
        {
        if (strcmp(jobid, jp->jobid) == 0)
          {
          return(TRUE);
          }
        }
      } /* END for each job on the subnode */
    } /* END for each subnode */

  /* not found */
  return(FALSE);
  } /* END check_node_for_job() */




/*
 * is_job_on_node - return TRUE if this jobid is present on pnode
 */

int is_job_on_node(

  struct pbsnode *pnode, /* I */
  char           *jobid) /* I */

  {
  struct pbsnode *numa;

  int             present = FALSE;
  char           *at;
  int             i;

  if ((at = strchr(jobid, (int)'@')) != NULL)
    *at = '\0'; /* strip off @server_name */

  if (pnode->num_node_boards > 0)
    {
    /* check each subnode on each numa node for the job */
    for (i = 0; i < pnode->num_node_boards; i++)
      {
      numa = AVL_find(i,pnode->nd_mom_port,pnode->node_boards);

      lock_node(numa, __func__, "before check_node_for_job numa", LOGLEVEL);
      present = check_node_for_job(pnode,jobid);
      unlock_node(numa, __func__, "after check_node_for_job numa", LOGLEVEL);

      /* leave loop if we found the job */
      if (present != FALSE)
        break;
      } /* END for each numa node */
    }
  else
    {
    present = check_node_for_job(pnode,jobid);
    }

  if (at != NULL)
    *at = '@';  /* restore @server_name */

  return(present);
  }  /* END is_job_on_node() */




/*
 * sync_node_jobs() - determine if a MOM has a stale job and possibly delete it
 *
 * This function is called every time we get a node stat from the pbs_mom.
 *
 * NOTE: changed to be processed in a thread so that processing here doesn't hinder
 * the server's ability to reply to the status
 *
 * @see is_stat_get()
 */

void *sync_node_jobs(

  void *vp)

  {
  struct pbsnode       *np;
  char                 *raw_input = (char *)vp;
  char                 *node_id;
  char                 *jobstring_in;
  char                 *joblist;
  char                 *jobidstr;
  char                  log_buf[LOCAL_LOG_BUF_SIZE];

  struct batch_request *preq;
  int                   conn;
  int                   local_errno = 0;

  job                  *pjob;

  if (vp == NULL)
    return(NULL);

  /* raw_input's format is:
   *   node name:<JOBID>[ <JOBID>]... */
  if ((jobstring_in = strchr(raw_input, ':')) != NULL)
    {
    node_id = raw_input;
    *jobstring_in = '\0';
    jobstring_in++;
    }
  else
    {
    /* bad input */

    return(NULL);
    }

  if (!isdigit(*jobstring_in))
    {
    /* NO-OP */
    free(raw_input);

    return(NULL);
    }

  /* FORMAT <JOBID>[ <JOBID>]... */
  joblist = jobstring_in;
  jobidstr = threadsafe_tokenizer(&joblist, " ");

  if ((np = find_nodebyname(node_id)) != NULL)
    {
    while ((jobidstr != NULL) && isdigit(*jobidstr))
      {
      if (strstr(jobidstr, server_name) != NULL)
        {
        if ((is_job_on_node(np, jobidstr)) == FALSE)
          {
          pjob = find_job(jobidstr);
          
          if (pjob != NULL)
            {
            /* job exists, but doesn't currently have resources assigned to this node */
            
            /* double check the job struct because we could be in the middle of moving
               the job around because of data staging, suspend, or rerun */            
            if (pjob->ji_wattr[JOB_ATR_exec_host].at_val.at_str == NULL)
              {
              pthread_mutex_unlock(pjob->ji_mutex);
              
              pjob = NULL;
              }
            else if (strstr(pjob->ji_wattr[JOB_ATR_exec_host].at_val.at_str, np->nd_name) == NULL)
              {
              pthread_mutex_unlock(pjob->ji_mutex);
              
              pjob = NULL;
              }
            else
              pthread_mutex_unlock(pjob->ji_mutex);
            }
          
          if (pjob == NULL)
            {
            /* job is reported by mom but server has no record of job */
            sprintf(log_buf, "stray job %s found on %s", jobidstr, np->nd_name);
            log_err(-1, __func__, log_buf);
            
            /* NOTE:  node is actively reporting so should not be deleted and
               np->nd_addrs[] should not be NULL */            
            conn = svr_connect(np->nd_addrs[0],pbs_mom_port,&local_errno,np,process_Dreply,ToServerDIS);
            
            if (conn >= 0)
              {
              if ((preq = alloc_br(PBS_BATCH_DeleteJob)) == NULL)
                {
                log_err(-1, __func__, "unable to allocate DeleteJob request-trouble!");
                
                svr_disconnect(conn);
                }
              else
                {
                strcpy(preq->rq_ind.rq_delete.rq_objname, jobidstr);
                if (issue_Drequest(conn, preq, release_req, 0) != 0)
                  {
                  /* release_req will free preq and close connection if successful */
                  free_br(preq);
                  
                  /* NOTE: only disconnect if we're unsuccesful - the mom has to reply on 
                   * this connection (see above comment for close connection */
                  svr_disconnect(conn);
                  }
                }
              }
            }
          } /* END is_job_on_node == NULL */
        }
      
      jobidstr = threadsafe_tokenizer(&joblist, " ");
      }  /* END while ((jobidstr != NULL) && ...) */
    
    if (np != NULL)
      unlock_node(np, __func__, "done syncing node jobs", LOGLEVEL);
    } /* end if np != NULL */

  /* SUCCESS */
  free(raw_input);

  return(NULL);
  }  /* END sync_node_jobs() */




/*
 * update_job_data() - update job with values passed through "jobdata"
 *
 * This function is called every time we get a "jobdata" status from the pbs_mom.
 *
 * @see is_stat_get()
 */

void update_job_data(

  struct pbsnode *np,            /* I */
  char           *jobstring_in)  /* I (changed attributes sent by mom) */

  {
  char      *id = "update_job_data";

  char      *jobdata;
  char      *jobdata_ptr;
  char      *jobidstr;
  char      *attr_name;
  char      *attr_value;
  char       log_buf[LOCAL_LOG_BUF_SIZE];

  struct job *pjob = NULL;
  int         on_node = FALSE;

  if ((jobstring_in == NULL) || (!isdigit(*jobstring_in)))
    {
    /* NO-OP */

    return;
    }

  /* FORMAT <JOBID>:<atrtributename=value>,<atrtributename=value>... */

  jobdata = strdup(jobstring_in);
  jobdata_ptr = jobdata;

  jobidstr = threadsafe_tokenizer(&jobdata_ptr, ":");

  if ((jobidstr != NULL) && isdigit(*jobidstr))
    {
    if (strstr(jobidstr, server_name) != NULL)
      {
      on_node = is_job_on_node(np, jobidstr);
      pjob = find_job(jobidstr);

      if (pjob != NULL)
        {
        int bad;

        svrattrl tA;
        
        /* job exists, so get the attributes and update them */
        attr_name = threadsafe_tokenizer(&jobdata_ptr, "=");
        
        while (attr_name != NULL)
          {
          attr_value = threadsafe_tokenizer(&jobdata_ptr, ",");
          
          if (LOGLEVEL >= 9)
            {
            sprintf(log_buf, "Mom sent changed attribute %s value %s for job %s",
              attr_name,
              attr_value,
              pjob->ji_qs.ji_jobid);
              
            log_event(PBSEVENT_JOB,PBS_EVENTCLASS_JOB,pjob->ji_qs.ji_jobid,log_buf);  
            }
          
          memset(&tA, 0, sizeof(tA));

          tA.al_name  = attr_name;
          tA.al_resc  = "";
          tA.al_value = attr_value;
          tA.al_op    = SET;

          modify_job_attr(
            pjob,
            &tA,                              /* I: ATTR_sched_hint - svrattrl */
            ATR_DFLAG_MGWR | ATR_DFLAG_SvWR,
            &bad);

          attr_name = threadsafe_tokenizer(&jobdata_ptr, "=");
          }
        
        pthread_mutex_unlock(pjob->ji_mutex);
        }
      
      if (on_node == FALSE)
        {
        /* job is reported by mom but server has no record of job */
        sprintf(log_buf, "stray job %s reported on %s", jobidstr, np->nd_name);

        log_err(-1, id, log_buf);
        }
      }
    }

  free(jobdata);
  }  /* END update_job_data() */




/*
 *      setup_notification -  Sets up the  mechanism for notifying
 *                            other members of the server's node
 *                            pool that a new node was added manually
 *                            via qmgr.  Actual notification occurs some
 *                            time later through the send_cluster_addrs mechanism
 */

void setup_notification(
    
  char *pname) /* I */

  {
  struct pbsnode *pnode;
  new_node       *nnew;

  if (pname != NULL)
    {
    if ((pnode = find_nodebyname(pname)) != NULL)
      {
      /* call it offline until after all nodes get the new ipaddr */
      pnode->nd_state |= INUSE_OFFLINE;
      
      nnew = calloc(1, sizeof(new_node));
      
      if (nnew == NULL)
        {
        unlock_node(pnode, "setup_notification", "nnew == NULL", LOGLEVEL);
        return;
        }
      
      CLEAR_LINK(nnew->nn_link);
      
      nnew->nn_name = strdup(pname);
      
      append_link(&svr_newnodes, &nnew->nn_link, nnew);
      
      unlock_node(pnode, "setup_notification", "nnew != NULL", LOGLEVEL);
      }
    }

  if (addrnote_mutex == NULL)
    {
    addrnote_mutex = calloc(1, sizeof(pthread_mutex_t));
    pthread_mutex_init(addrnote_mutex,NULL);
    }

  pthread_mutex_lock(addrnote_mutex);
  num_addrnote_tasks++;
  pthread_mutex_unlock(addrnote_mutex);

  return;
  }





int is_stat_get(

  struct pbsnode *np)  /* I (modified) */

  {
  char           *id = "is_stat_get";

  struct pbsnode *orig_np = np;
  int             stream = np->nd_stream;
  int             rc;
  char           *ret_info;
  char            log_buf[LOCAL_LOG_BUF_SIZE];
  attribute       temp;
  char            date_attrib[100];
  int             msg_error = 0;
  struct pbssubn *sp = NULL;
  time_t          time_now = time(NULL);
  long            mom_job_sync = FALSE;
  long            auto_np = FALSE;
  long            np_default = FALSE;
  long            down_on_error = FALSE;

  extern int TConnGetSelectErrno();
  extern int TConnGetReadErrno();

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buf, "received status from node %s",
      (np != NULL) ? np->nd_name : "NULL");

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
    }

  if (stream < 0)
    {
    return(DIS_EOF);
    }

  get_svr_attr_l(SRV_ATR_MomJobSync, &mom_job_sync);
  get_svr_attr_l(SRV_ATR_AutoNodeNP, &auto_np);
  get_svr_attr_l(SRV_ATR_NPDefault, &np_default);
  get_svr_attr_l(SRV_ATR_DownOnError, &down_on_error);

  /*
   *  Before filling the "temp" attribute, initialize it.
   *  The second and third parameter to decode_arst are never
   *  used, so just leave them empty. (GBS)
   */

  memset(&temp, 0, sizeof(temp));
  memset(date_attrib, 0, 100);

  rc = DIS_SUCCESS;

  if (decode_arst(&temp, NULL, NULL, NULL, 0))
    {
    log_record(PBSEVENT_DEBUG, PBS_EVENTCLASS_NODE, id, "cannot initialize attribute");
    return(DIS_NOCOMMIT);
    }

  unlock_node(np, id, "np numa update", LOGLEVEL);
  while (((ret_info = disrst(stream, &rc)) != NULL) && 
         (rc == DIS_SUCCESS))
    {
    lock_node(np, id, "np numa update", LOGLEVEL);
    /* check if this is the update on a numa node */
    if (!strncmp(ret_info,NUMA_KEYWORD,strlen(NUMA_KEYWORD)))
      {
      char *numa_id;
      struct pbsnode *tmp;
      unsigned long numa_index;

      if (np->node_boards == NULL)
        {
        /* ERROR */
        snprintf(log_buf,sizeof(log_buf),
          "Node %s isn't declared to be NUMA, but mom is reporting\n",
          np->nd_name);
        log_err(-1,id,log_buf);

        return(DIS_NOCOMMIT);
        }

      numa_id = ret_info + strlen(NUMA_KEYWORD);
      numa_index = atoi(numa_id);

      tmp = AVL_find(numa_index,orig_np->nd_mom_port,orig_np->node_boards);

      if (tmp == NULL)
        {
        /* ERROR */
        snprintf(log_buf,sizeof(log_buf),
          "Could not find NUMA index %lu for node %s\n",
          numa_index,
          np->nd_name);
        log_err(-1,id,log_buf);

        return(DIS_NOCOMMIT);
        }
      
      unlock_node(np, id, "np numa update", LOGLEVEL);
      lock_node(tmp, id, "tmp numa update", LOGLEVEL);

      np = tmp;

      np->nd_lastupdate = time_now;

      unlock_node(np, id, "np numa update", LOGLEVEL);
      /* resume normal processing on the next line */
      free(ret_info);
      continue;
      }
    else if (!strncmp(ret_info,"node=",strlen("node=")))
      {
      /* this is a node reporting on another node as well */
      char           *node_id = ret_info + strlen("node=");
      struct pbsnode *tmp;

      if (strcmp(node_id,np->nd_name))
        {
        unlock_node(np, id, "np not numa update", LOGLEVEL);
        
        tmp = find_nodebyname(node_id);
        
        if (tmp == NULL)
          {
          /* NYI: should we add logic here to attempt the canonical name if this 
           * is the short name, and attempt the short name if this is the 
           * canonical name? */

          /* ERROR */
          snprintf(log_buf,sizeof(log_buf),
            "Node %s is reporting on node %s, which pbs_server doesn't know about\n",
            orig_np->nd_name,
            node_id);
          log_err(-1,id,log_buf);
          
          return(DIS_NOCOMMIT);
          }
        
        if (LOGLEVEL >= 7)
          {
          snprintf(log_buf,sizeof(log_buf),
            "Node %s is reporting for node %s\n",
            orig_np->nd_name,
            node_id);
          
          log_event(PBSEVENT_SYSTEM,PBS_EVENTCLASS_SERVER,id,log_buf);
          }
        
        np = tmp;
        }

      np->nd_lastupdate = time_now;

      unlock_node(np, id, "np numa update", LOGLEVEL);
      /* resume normal processing on the next time */
      free(ret_info);
      continue;
      }

    /* add the info to the "temp" attribute */
    if (!strncmp(ret_info, IS_EOL_MESSAGE, strlen(IS_EOL_MESSAGE)))
      {
      /* Skip this one */
      }
    else if (!strcmp(ret_info, "first_update=true"))
      {
      /* mom is requesting that we send the mom hierarchy file to her */
      hello_info *hi = calloc(1, sizeof(hello_info));
      hi->name = strdup(np->nd_name);
      remove_hello(&hellos, hi->name);
      enqueue_threadpool_request(send_hierarchy_threadtask, hi);
      }
    else if (decode_arst(&temp, NULL, NULL, ret_info, 0))
      {
      DBPRT(("is_stat_get: cannot add attributes\n"));

      free_arst(&temp);

      free(ret_info);

      if (orig_np != np)
        {
        unlock_node(np, id, "np->orig_np", LOGLEVEL);
        lock_node(orig_np, id, "orig_np", LOGLEVEL);
        }

      return(DIS_NOCOMMIT);
      }

    if (!strncmp(ret_info, "state", 5))
      {
      /* MOM currently never sends multiple states - bad assumption for the future? */

      if (!strncmp(ret_info, "state=down", 10))
        {
        update_node_state(np, INUSE_DOWN);
        }
      else if (!strncmp(ret_info, "state=busy", 10))
        {
        update_node_state(np, INUSE_BUSY);
        }
      else if (!strncmp(ret_info, "state=free", 10))
        {
        update_node_state(np, INUSE_FREE);
        }
      else
        {
        sprintf(log_buf, "unknown %s from node %s",
          ret_info,
          (np->nd_name != NULL) ? np->nd_name : "NULL");

        log_err(-1, id, log_buf);

        update_node_state(np, INUSE_UNKNOWN);
        }

      if (LOGLEVEL >= 9)
        {
        sprintf(log_buf, "node '%s' is at state '0x%x'\n",
          np->nd_name,
          np->nd_state);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
        }

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        if (!(np->nd_state & INUSE_OFFLINE) &&
            (sp->inuse & INUSE_OFFLINE))
          {
          /* this doesn't seem to ever happen */

          if (LOGLEVEL >= 2)
            {
            sprintf(log_buf, "sync'ing subnode state '%s' with node state on node %s\n",
              "offline",
              np->nd_name);
 
            log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
            }
 
          sp->inuse &= ~INUSE_OFFLINE;
          }

        sp->inuse &= ~INUSE_DOWN;
        }
      }
    else if (!strncmp(ret_info, "uname", 5) && allow_any_mom)
      {
      /* for any mom mode if an address did not succeed at getnameinfo it was
       * given the hex value of its ip address */
      if (!strncmp(np->nd_name, "0x", 2))
        {
        char *cp;
        char node_name[PBS_MAXHOSTNAME + 1];
        int count;
        
        cp = strchr(ret_info, ' ');
        count = 0;
        
        do
          {
          cp++;
          node_name[count] = *cp;
          count++;
          } while (*cp != ' ' && count < PBS_MAXHOSTNAME);

        node_name[count-1] = 0;
        cp = strdup(node_name);
        free(np->nd_name);
        np->nd_name = cp;
        np->nd_first = init_prop(np->nd_name);
        np->nd_last = np->nd_first;
        np->nd_f_st = init_prop(np->nd_name);
        np->nd_l_st = np->nd_f_st;
        }
      }
    else if (!strncmp(ret_info, "me", 2))  /* shorter str compare than "message" */
      {
      if (!strncmp(ret_info, "message=ERROR", 13))
        {
        msg_error = 1;
        }
      }
    else if (mom_job_sync &&
             !strncmp(ret_info, "jobdata=", 8))
      {
      /* update job attributes based on what the MOM gives us */      
      update_job_data(np, ret_info + strlen("jobdata="));
      }
    else if (mom_job_sync &&
             !strncmp(ret_info, "jobs=", 5))
      {
      /* walk job list reported by mom */
      size_t  len = strlen(ret_info) + PBS_MAXNODENAME + 2;
      char   *str = calloc(1, len);

      sprintf(str, "%s:%s", np->nd_name, ret_info);
      enqueue_threadpool_request(sync_node_jobs, str);
      }
    else if (auto_np)
      {
      if (!(strncmp(ret_info, "ncpus=", 6)))
        {        
        struct attribute nattr;
        
        /* first we decode ret_info into nattr... */
        
        if ((node_attr_def + ND_ATR_np)->at_decode(&nattr, ATTR_NODE_np, NULL, ret_info + 6, 0) == 0)
          {
          /* ... and if MOM's ncpus is different than our np... */
          if (nattr.at_val.at_long != np->nd_nsn)
            {
            /* ... then we do the defined magic to create new subnodes */
            (node_attr_def + ND_ATR_np)->at_action(&nattr, (void *)np, ATR_ACTION_ALTER);
            
            update_nodes_file(np);
            }
          }
        }
      }
    else if (np_default)
      {
      struct pbsnode *pnode;
      int             iter = -1;
      long            nsnfreediff;
      
      while ((pnode = next_host(&allnodes,&iter,NULL)) != NULL)
        {
        nsnfreediff = pnode->nd_nsn - pnode->nd_nsnfree;
        pnode->nd_nsn = np_default;
        pnode->nd_nsnfree = np_default - nsnfreediff;
       
        unlock_node(pnode, id, "SRV_ATR_NPDefault", LOGLEVEL);
        }
      }
    else if (!strncmp(ret_info, IS_EOL_MESSAGE, strlen(IS_EOL_MESSAGE)))
      {
      if (LOGLEVEL >= 6)
        {
        snprintf(log_buf, sizeof(log_buf),
          "End of message detected for communication from node %s",
          orig_np->nd_name);

        log_event(PBSEVENT_DEBUG, PBS_EVENTCLASS_NODE, id, log_buf);
        }
      unlock_node(np, id, "np numa update", LOGLEVEL);
      rc = DIS_EOD;
      free(ret_info);
      break;
      }

    unlock_node(np, id, "np numa update", LOGLEVEL);
    free(ret_info);
    }    /* END while (rc != DIS_EOD) */

  /* clear the transmission */
  DIS_tcp_reset(stream,0);

  lock_node(np, id, "np numa update", LOGLEVEL);
  /* DIS_EOD and DIS_EOF are the only valid final values of rc, check it */
  if ((rc != DIS_EOD) &&
      (rc != DIS_EOF))
    {
    update_node_state(np, INUSE_UNKNOWN);

    free_arst(&temp);
      
    if (orig_np != np)
      {
      unlock_node(np, id, "!DIS_EOD/F np->orig_np", LOGLEVEL);
      lock_node(orig_np, id, "!DIS_EOD/F orig_np", LOGLEVEL);
      }

    return(rc);
    }

  if (msg_error && down_on_error)
    {
    update_node_state(np, INUSE_DOWN);
    }

  /* it's nice to know when the last update happened */

  sprintf(date_attrib, "rectime=%ld",
          (long)time_now);

  if (decode_arst(&temp, NULL, NULL, date_attrib, 0))
    {
    DBPRT(("is_stat_get:  cannot add date_attrib\n"));

    free_arst(&temp);
      
    if (orig_np != np)
      {
      unlock_node(np, id, "decode_arst np->orig_np", LOGLEVEL);
      lock_node(orig_np, id, "decode_arst orig_np", LOGLEVEL);
      }

    return(DIS_NOCOMMIT);
    }


  /* insert the information from "temp" into np */

  if (node_status_list(&temp, np, ATR_ACTION_ALTER))
    {
    DBPRT(("is_stat_get: cannot set node status list\n"));
      
    if (orig_np != np)
      {
      unlock_node(np, id, "node_status_list np->orig_np", LOGLEVEL);
      lock_node(orig_np, id, "node_status_list orig_np", LOGLEVEL);
      }

    return(DIS_NOCOMMIT);
    }

  /* NOTE:  node state adjusted in update_node_state() */
  if (orig_np != np)
    {
    unlock_node(np, id, "final np->orig_np", LOGLEVEL);
    lock_node(orig_np, id, "final orig_np", LOGLEVEL);
    }

  return(DIS_SUCCESS);
  }  /* END is_stat_get() */



#ifdef NVIDIA_GPUS
/*
 * Function to check if there is a job assigned to this gpu
 */

int gpu_has_job(

  struct pbsnode *pnode,
  int  gpuid)

  {
  job            *pjob;
  char           *gpu_str;
  char           *found_str;
  /* increased so that really high gpu indexes don't bother us */
  char            tmp_str[PBS_MAXHOSTNAME + 10];
  struct pbssubn *np;
  struct jobinfo *jp;

  /* check each subnode for a job using a gpuid */
  for (np = pnode->nd_psn;np != NULL;np = np->next)
    {
    /* for each jobinfo on subnode on node ... */
    for (jp = np->jobs;jp != NULL;jp = jp->next)
      {
      if (jp->jobid != NULL)
        {
        if ((pjob = get_job_from_jobinfo(jp,pnode)) != NULL)
          {
          /* Does this job have this gpuid assigned? */
          if ((pjob->ji_qs.ji_state == JOB_STATE_RUNNING) &&
              (pjob->ji_wattr[JOB_ATR_exec_gpus].at_flags & ATR_VFLAG_SET) != 0)
            {
            gpu_str = pjob->ji_wattr[JOB_ATR_exec_gpus].at_val.at_str;
            
            if (gpu_str != NULL)
              {
              snprintf(tmp_str, sizeof(tmp_str), "%s-gpu/%d",
                pnode->nd_name, gpuid);
              
              /* look thru the string and see if it has this host and gpuid.
               * exec_gpus string should be in format of 
               * <hostname>-gpu/<index>[+<hostname>-gpu/<index>...]
               */
              
              found_str = strstr (gpu_str, tmp_str);
              if (found_str != NULL)
                {
                pthread_mutex_unlock(pjob->ji_mutex);
                return(TRUE);
                }
              }
            }
          
          /* done with job, unlock the mutex */
          pthread_mutex_unlock(pjob->ji_mutex);
          }
        }
      } /* END for each job on the subnode */
    } /* END for each subnode */

  return(FALSE);
  }
#endif  /* NVIDIA_GPUS */



#ifdef NVIDIA_GPUS
/*
 * Function to process gpu status messages received from the mom
 */

int is_gpustat_get(

  struct pbsnode *np)  /* I (modified) */

  {
  char      *id = "is_gpustat_get";

  int stream = np->nd_stream;
  int        rc;
  char      *ret_info;
  attribute  temp;
  char      *gpuid;
  char       log_buf[LOCAL_LOG_BUF_SIZE];
  int        gpuidx = -1;
  char       gpuinfo[2048];
  int        need_delimiter;
  int        gpucnt = 0;
  int        drv_ver;

  extern int TConnGetSelectErrno();
  extern int TConnGetReadErrno();

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buf, "received gpu status from node %s",
      (np != NULL) ? np->nd_name : "NULL");

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
    }

  if (stream < 0)
    {
    return(DIS_EOF);
    }

  /*
   *  Before filling the "temp" attribute, initialize it.
   *  The second and third parameter to decode_arst are never
   *  used, so just leave them empty. (GBS)
   */

  memset(&temp, 0, sizeof(temp));
  memset(gpuinfo, 0, 2048);

  rc = DIS_SUCCESS;

  if (decode_arst(&temp, NULL, NULL, NULL, 0))
    {
    DBPRT(("is_gpustat_get:  cannot initialize attribute\n"));

    rpp_eom(stream);

    return(DIS_NOCOMMIT);
    }

  while (((ret_info = disrst(stream, &rc)) != NULL) && (rc == DIS_SUCCESS))
    {
    /* add the info to the "temp" attribute */

    /* get timestamp */
    if (!strncmp(ret_info, "timestamp=", 10))
      {
      if (decode_arst(&temp, NULL, NULL, ret_info, 0))
        {
        DBPRT(("is_gpustat_get: cannot add attributes\n"));

        free_arst(&temp);

        free(ret_info);

        rpp_eom(stream);

        return(DIS_NOCOMMIT);
        }
      continue;
      }

    /* get driver version, if there is one */
    if (!strncmp(ret_info, "driver_ver=", 11))
      {
      if (decode_arst(&temp, NULL, NULL, ret_info, 0))
        {
        DBPRT(("is_gpustat_get: cannot add attributes\n"));

        free_arst(&temp);

        free(ret_info);

        rpp_eom(stream);

        return(DIS_NOCOMMIT);
        }
      drv_ver = atoi(ret_info + 11);
      continue;
      }

    /* gpuid must come before the rest or we will be in trouble */

    if (!strncmp(ret_info, "gpuid=", 6))
      {
      if (strlen(gpuinfo) > 0)
        {
        if (decode_arst(&temp, NULL, NULL, gpuinfo, 0))
          {
          DBPRT(("is_gpustat_get: cannot add attributes\n"));

          free_arst(&temp);

          free(ret_info);

          rpp_eom(stream);

          return(DIS_NOCOMMIT);
          }
        memset(gpuinfo, 0, 2048);
        }

      gpuid = &ret_info[6];

      /*
       * Get this gpus index, if it does not yet exist then find an empty entry.
       * We need to allow for the gpu status results being returned in
       * different orders since the nvidia order may change upon mom's reboot
       */

      gpuidx = gpu_entry_by_id(np, gpuid, TRUE);
      if (gpuidx == -1)
        {
        /*
         * Failure - we could not get / create a nd_gpusn entry for this gpu,
         * log an error message.
         */

        if (LOGLEVEL >= 3)
          {
          sprintf(log_buf,
            "Failed to get/create entry for gpu %s on node %s\n",
            gpuid,
            np->nd_name);

          log_ext(-1, id, log_buf, LOG_DEBUG);
          }

        free_arst(&temp);

        free(ret_info);

        return(DIS_SUCCESS);
        }

      sprintf(gpuinfo, "gpu[%d]=gpu_id=%s;", gpuidx, gpuid);
      need_delimiter = FALSE;
      gpucnt++;
      np->nd_gpusn[gpuidx].driver_ver = drv_ver;

      /* mark that this gpu node is not virtual */
      np->nd_gpus_real = TRUE;
      
      /*
       * if we have not filled in the gpu_id returned by the mom node
       * then fill it in
       */
      if ((gpuidx >= 0) && (np->nd_gpusn[gpuidx].gpuid == NULL))
        {
        np->nd_gpusn[gpuidx].gpuid = strdup(gpuid);
        }      

      }
    else
      {
      if (need_delimiter)
        {
        strcat(gpuinfo, ";");
        }
      strcat(gpuinfo, ret_info);
      need_delimiter = TRUE;
      }

    /* check current gpu mode and determine gpu state */
    
    if (!memcmp(ret_info, "gpu_mode=", 9))
      {
      if ((!memcmp(ret_info+9, "Normal", 6)) || (!memcmp(ret_info+9, "Default", 7)))
        {
        np->nd_gpusn[gpuidx].mode = gpu_normal;
        if (gpu_has_job(np, gpuidx))
          {
          np->nd_gpusn[gpuidx].state = gpu_shared;
          }
        else
          {
          np->nd_gpusn[gpuidx].inuse = 0;
          np->nd_gpusn[gpuidx].state = gpu_unallocated;
          }
        }
      else if ((!memcmp(ret_info+9, "Exclusive", 9)) ||
              (!memcmp(ret_info+9, "Exclusive_Thread", 16)))
        {
        np->nd_gpusn[gpuidx].mode = gpu_exclusive_thread;
        if (gpu_has_job(np, gpuidx))
          {
          np->nd_gpusn[gpuidx].state = gpu_exclusive;
          }
        else
          {
          np->nd_gpusn[gpuidx].inuse = 0;
          np->nd_gpusn[gpuidx].state = gpu_unallocated;
          }
        }
      else if (!memcmp(ret_info+9, "Exclusive_Process", 17))
        {
        np->nd_gpusn[gpuidx].mode = gpu_exclusive_process;
        if (gpu_has_job(np, gpuidx))
          {
          np->nd_gpusn[gpuidx].state = gpu_exclusive;
          }
        else
          {
          np->nd_gpusn[gpuidx].inuse = 0;
          np->nd_gpusn[gpuidx].state = gpu_unallocated;
          }
        }
      else if (!memcmp(ret_info+9, "Prohibited", 10))
        {
        np->nd_gpusn[gpuidx].mode = gpu_prohibited;
        np->nd_gpusn[gpuidx].state = gpu_unavailable;
        }
      else
        {
        /* unknown mode, default to prohibited */
        np->nd_gpusn[gpuidx].mode = gpu_prohibited;
        np->nd_gpusn[gpuidx].state = gpu_unavailable;
        if (LOGLEVEL >= 3)
          {
          sprintf(log_buf,
            "GPU %s has unknown mode on node %s",
            gpuid,
            np->nd_name);

          log_ext(-1, id, log_buf, LOG_DEBUG);
          }
        }
 
      /* add gpu_mode so it gets added to the attribute */

      if (need_delimiter)
        {
        strcat(gpuinfo, ";");
        }

      switch (np->nd_gpusn[gpuidx].state)
        {
        case gpu_unallocated:
          strcat (gpuinfo, "gpu_state=Unallocated");
          break;
        case gpu_shared:
          strcat (gpuinfo, "gpu_state=Shared");
          break;
        case gpu_exclusive:
          strcat (gpuinfo, "gpu_state=Exclusive");
          break;
        case gpu_unavailable:
          strcat (gpuinfo, "gpu_state=Unavailable");
          break;
        }
      }

    } /* end of while disrst */

    if (strlen(gpuinfo) > 0)
      {
      if (decode_arst(&temp, NULL, NULL, gpuinfo, 0))
        {
        DBPRT(("is_gpustat_get: cannot add attributes\n"));

        free_arst(&temp);

        free(ret_info);

        rpp_eom(stream);

        return(DIS_NOCOMMIT);
        }
      }

  /* maintain the gpu count */

  if (gpucnt != np->nd_ngpus)
    {
    np->nd_ngpus = gpucnt;

    /* update the nodes file */

    update_nodes_file(np);
    }

  node_gpustatus_list(&temp, np, ATR_ACTION_ALTER);

  return(DIS_SUCCESS);

  }  /* END is_gpustat_get() */
#endif  /* NVIDIA_GPUS */



/*
** Start a standard inter-server message.
*/

int is_compose(

  int stream,  /* I */
  int command) /* I */

  {
  int ret;

  if (stream < 0)
    {
    return(DIS_EOF);
    }

  ret = diswsi(stream, IS_PROTOCOL);

  if (ret != DIS_SUCCESS)
    goto done;

  ret = diswsi(stream, IS_PROTOCOL_VER);

  if (ret != DIS_SUCCESS)
    goto done;

  ret = diswsi(stream, command);

  if (ret != DIS_SUCCESS)
    goto done;

  return(DIS_SUCCESS);

done:

  DBPRT(("is_compose: send error %s\n",
         dis_emsg[ret]))

  return(ret);
  }  /* END is_compose() */




/* EOF on a stream received (either stream or addr must be specified) */
/* mark node down and remove associated streams */
/* NOTE: pass in stream = -1 if you wish the stream to be optional */

void stream_eof(

  int       stream,  /* I (optional) */
  u_long    addr,  /* I (optional) */
  uint16_t  port,  /* I (optional) */
  int       ret)     /* I (ignored) */

  {
  static char     id[] = "stream_eof";
  char            log_buf[LOCAL_LOG_BUF_SIZE];

  struct pbsnode *np;


  np = NULL;

  if (stream >= 0)
    {
    close(stream);

    /* find who the stream belongs to and mark down */
    np = AVL_find(stream, 0, streams);
    }

  if ((np == NULL) && (addr != 0))
    {
    np = AVL_find(addr, port, ipaddrs);
    }

  if (np == NULL)
    {
    /* cannot locate node */

    return;
    }

  lock_node(np, id, "parent", LOGLEVEL);

  sprintf(log_buf,
    "connection to %s is no longer valid, connection may have been closed remotely, remote service may be down, or message may be corrupt (%s).  setting node state to down",
    np->nd_name,
    dis_emsg[ret]);

  log_err(-1, id, log_buf);

  /* mark node and all subnodes as down */

  if (np->num_node_boards > 0)
    {
    int             i;
    struct pbsnode *pnode;

    for (i = 0; i < np->num_node_boards; i++)
      {
      pnode = AVL_find(i,np->nd_mom_port,np->node_boards);

      lock_node(pnode, id, "subs", LOGLEVEL);
      update_node_state(pnode,INUSE_DOWN);
      unlock_node(pnode, id, "subs", LOGLEVEL);
      }
    }
  else
    update_node_state(np, INUSE_DOWN);

  /* remove stream from list of valid connections */

  if (np->nd_stream >= 0)
    {
    streams = AVL_delete_node(np->nd_stream, 0, streams);

    np->nd_stream = -1;
    }

  unlock_node(np, id, "parent", LOGLEVEL);

  return;
  }  /* END stream_eof() */





/* add_cluster_addrs - add the IPaddr of every node to the stream */

int add_cluster_addrs(

  int stream,           /* I */
  struct pbsnode *held) /* I */

  {
  static char     id[] = "add_cluster_addrs";
  char            log_buf[LOCAL_LOG_BUF_SIZE];

  int             iter = -1;
  int             j;
  int             ret;

  struct pbsnode *np;

  /* should we cache this response and send it as a single string? */
  while ((np = next_host(&allnodes,&iter,held)) != NULL)
    {
    if (LOGLEVEL == 7)  /* higher loglevel gets more info below */
      {
      sprintf(log_buf, "adding node %s to hello response", np->nd_name);

      log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
      }

    for (j = 0; np->nd_addrs[j]; j++)
      {
      u_long ipaddr = np->nd_addrs[j];

      if (LOGLEVEL >= 8)
        {
        char *tmp = netaddr_pbs_net_t(ipaddr);
        sprintf(log_buf, "adding node interface[%d] %s to hello response",
          j,
          tmp);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);

        free(tmp);
        }

      ret = diswul(stream, ipaddr);

      if (ret != DIS_SUCCESS)
        {
        /* FAILURE */
        if (np != held)
          unlock_node(np, id, "failure", LOGLEVEL);

        return(ret);
        }
      }  /* END for (j) */

    if (np != held)
      unlock_node(np, id, "success", LOGLEVEL);
    }    /* END for (i) */

  return(DIS_SUCCESS);
  } /* END add_cluster_addrs */




/*
 * wrapper task that check_nodes places in the thread pool's queue
 */
void *check_nodes_work(

  void *vp)

  {
  static char       id[] = "check_nodes_work";

  work_task *ptask = (struct work_task *)vp;

  struct pbsnode   *np = NULL;
  long              chk_len = 300;
  char              log_buf[LOCAL_LOG_BUF_SIZE];
  time_t            time_now = time(NULL);

  node_iterator     iter;
  
  /* load min refresh interval */
  get_svr_attr_l(SRV_ATR_check_rate, &chk_len);

  if (LOGLEVEL >= 5)
    {
    sprintf(log_buf, "verifying nodes are active (min_refresh = %d seconds)", (int)chk_len);

    log_event(PBSEVENT_ADMIN,PBS_EVENTCLASS_SERVER,id,log_buf);
    }

  /* evaluate all nodes */
  reinitialize_node_iterator(&iter);

  while ((np = next_node(&allnodes,np,&iter)) != NULL)
    {
    if (!(np->nd_state & INUSE_DOWN))
      {
      if (np->nd_lastupdate < (time_now - chk_len)) 
        {
        if (LOGLEVEL >= 0)
          {
          sprintf(log_buf, "node %s not detected in %ld seconds, marking node down",
            np->nd_name,
            (long int)(time_now - np->nd_lastupdate));
          
          log_event(PBSEVENT_ADMIN,PBS_EVENTCLASS_SERVER,id,log_buf);
          }
        
        update_node_state(np, (INUSE_DOWN));    
        }
      }
    } /* END for each node */

  if (ptask->wt_parm1 == NULL)
    {
    set_task(WORK_Timed,time_now + chk_len,check_nodes,NULL,FALSE);
    }

  /* since this is done via threading, we now free the task here */
  free(ptask->wt_mutex);
  free(ptask);

  return(NULL);
  } /* check_nodes_work() */




/*
 * Mark any nodes that haven't checked in as down.
 * If the node isn't down then it checks to see that the
 * last update hasn't been too long ago.
 */

void check_nodes(

  struct work_task *ptask)  /* I (modified) */

  {
  static char id[] = "check_nodes";
  int rc = enqueue_threadpool_request(check_nodes_work,ptask);

  if (rc)
    {
    log_err(rc,id,"Unable to enqueue check nodes task into the threadpool");
    }
  }  /* END check_nodes() */



/* sync w/#define IS_XXX */

const char *PBSServerCmds2[] =
  {
  "NULL",
  "HELLO",
  "CLUSTER_ADDRS",
  "UPDATE",
  "STATUS",
  "GPU_STATUS",
  NULL
  };




/* 
 * is_request_work
 * the function that performs the processing of the is_request. This function is 
 * passed to the threadpool to be started from there.
 *
 * vp is an array of int pointers. 
 * The first slot is the socket number 
 * The second slot is the version
 */

void *is_request_work(

  void *vp)

  {
  static char         id[] = "is_request_work";

  int                 command = 0;
  int                 ret = DIS_SUCCESS;
  int                 i;
  int                 err;
  char                nodename[PBS_MAXHOSTNAME];
  int                 perm = ATR_DFLAG_MGRD | ATR_DFLAG_MGWR;

  unsigned long       ipaddr;
  unsigned short      mom_port;
  unsigned short      rm_port;
  unsigned long       tmpaddr;

  struct sockaddr_in *addr = NULL;
  struct sockaddr     s_addr;
  unsigned int        len = sizeof(s_addr);

  struct pbsnode     *node = NULL;

  char                log_buf[LOCAL_LOG_BUF_SIZE];
#ifdef NVIDIA_GPUS
  time_t              time_now = time(NULL);
#endif

  int                 sock;
  int                 version;
  int                *args = (int *)vp;

  sock = args[0];
  version = args[1];

  command = disrsi(sock, &ret);

  if (ret != DIS_SUCCESS)
    goto err;

  if (LOGLEVEL >= 4)
    {
    sprintf(log_buf,
      "message received from sock %d (version %d)",
      sock,
      version);

    log_event(PBSEVENT_ADMIN,PBS_EVENTCLASS_SERVER,id,log_buf);
    }

  if (getpeername(sock, &s_addr, &len) != 0)
    {
    close_conn(sock, FALSE);

    free(vp);

    log_err(errno,id,"Cannot get socket name using getpeername\n");

    return(NULL);
    }

  addr = (struct sockaddr_in *)&s_addr;

  mom_port = disrsi(sock, &ret);
  rm_port = disrsi(sock, &ret);

  if (version != IS_PROTOCOL_VER)
    {
    sprintf(log_buf,
      "protocol version %d unknown from %s",
      version,
      netaddr(addr));

    log_err(-1, id, log_buf);

    close_conn(sock, 2);

    free(vp);
  
    return(NULL);
    }

  /* check that machine is known */

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buf,
      "message received from sock %s: mom_port %d  - rm_port %d",
      netaddr(addr),
      mom_port,
      rm_port);

    log_event(PBSEVENT_ADMIN,PBS_EVENTCLASS_SERVER,id,log_buf);
    }

  ipaddr = ntohl(addr->sin_addr.s_addr);
  
  if ((node = AVL_find(ipaddr, mom_port, ipaddrs)) != NULL)
    {
    lock_node(node, id, "AVL_find", LOGLEVEL);
    } /* END if AVL_find != NULL) */
  else if (allow_any_mom)
    {
    if (getnameinfo(&s_addr, len, nodename, sizeof(nodename), NULL, 0, 0) != 0)
      {
      tmpaddr = ntohl(addr->sin_addr.s_addr);
      sprintf(nodename, "0x%lX", tmpaddr);
      }

    err = create_partial_pbs_node(nodename, ipaddr, perm);

    if (err == PBSE_NONE)
      {
      node = AVL_find(ipaddr, 0, ipaddrs);
       
      lock_node(node, id, "no error", LOGLEVEL);
      }                                                         
    }
    
  if (node == NULL)
    {
    /* node not listed in trusted ipaddrs list */
    
    sprintf(log_buf,
      "bad attempt to connect from %s (address not trusted - check entry in server_priv/nodes)",
      netaddr(addr));
    
    if (LOGLEVEL >= 2)
      {
      log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buf);
      }
    
    log_err(-1, id, log_buf);
    
    close_conn(sock, FALSE);
    
    free(vp);
 
    return(NULL);
    }

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buf,
      "message %s (%d) received from mom on host %s (%s) (sock %d)",
      PBSServerCmds2[command],
      command,
      node->nd_name,
      netaddr(addr),
      sock);

    log_event(PBSEVENT_ADMIN,PBS_EVENTCLASS_SERVER,id,log_buf);
    }

  switch (command)
    {
    case IS_NULL:  /* a ping from server */

      DBPRT(("%s: IS_NULL\n",
             id))

      break;

    case IS_HELLO:

      if (LOGLEVEL >= 1)
        {
        sprintf(log_buf, "HELLO received from %s", node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
        }

#ifndef ALT_CLSTR_ADDR
      ret = is_compose(sock, IS_CLUSTER_ADDRS);

      if (ret != DIS_SUCCESS)
        goto err;

      if (LOGLEVEL >= 6)
        {
        sprintf(log_buf, "Add cluster addrs to %s", node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
        }

      if (add_cluster_addrs(sock,node) != DIS_SUCCESS)
        goto err;

      ret = DIS_tcp_wflush(sock);

      if (ret != DIS_SUCCESS)
        goto err;

      if (LOGLEVEL >= 3)
        {
        sprintf(log_buf, "sending cluster-addrs to node %s\n", node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
        }

      /* CLUSTER_ADDRS successful */
#endif
      node->nd_state &= ~(INUSE_NEEDS_HELLO_PING);

      break;

    case IS_UPDATE:

      DBPRT(("%s: IS_UPDATE\n",
             id))

      i = disrui(sock, &ret);

      if (ret != DIS_SUCCESS)
        {
        if (LOGLEVEL >= 1)
          {
          sprintf(log_buf, "IS_UPDATE error %d on node %s\n", ret, node->nd_name);

          log_err(ret, id, log_buf);
          }

        goto err;
        }

      DBPRT(("%s: IS_UPDATE %s 0x%x\n",

             id,
             node->nd_name,
             i))

      update_node_state(node, i);

      break;

    case IS_STATUS:

      /* pbs_server brought up
         pbs_mom brought up
         they send IS_HELLO to each other
         pbs_mom sends IS_STATUS message to pbs_server (replying to IS_HELLO)
         pbs_server sends IS_CLUSTER_ADDRS message to pbs_mom  (replying to IS_HELLO)
         pbs_mom uses IS_CLUSTER_ADDRS message to authorize contacts from sisters */

      if (LOGLEVEL >= 2)
        {
        sprintf(log_buf, "IS_STATUS received from %s", node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
        }

      node->nd_stream = sock;

      ret = is_stat_get(node);
      socket_read_flush(sock);

      write_tcp_reply(sock,IS_PROTOCOL,IS_PROTOCOL_VER,IS_STATUS,ret);

      node->nd_stream = -1;

      if (ret != DIS_SUCCESS)
        {
        if (LOGLEVEL >= 1)
          {
          sprintf(log_buf, "IS_STATUS error %d on node %s", ret, node->nd_name);

          log_err(ret, id, log_buf);
          }

        goto err;
        }

      break;

    case IS_GPU_STATUS:

      /* pbs_server brought up
         pbs_mom brought up
         they send IS_HELLO to each other
         pbs_mom sends IS_STATUS followed by
         IS_GPU_STATUS message to pbs_server (replying to IS_HELLO)
         pbs_server sends IS_CLUSTER_ADDRS message to pbs_mom  (replying to IS_HELLO)
         pbs_mom uses IS_CLUSTER_ADDRS message to authorize contacts from sisters */

#ifdef NVIDIA_GPUS
      if (LOGLEVEL >= 2)
        {
        sprintf(log_buf, "IS_GPU_STATUS received from %s", node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buf);
        }

      ret = is_gpustat_get(node);

      if (ret != DIS_SUCCESS)
        {
        if (LOGLEVEL >= 1)
          {
          sprintf(log_buf, "IS_GPU_STATUS error %d on node %s",
            ret,
            node->nd_name);

          log_err(ret, id, log_buf);
          }

        goto err;
        }

      node->nd_lastupdate = time_now;
#else
      if (LOGLEVEL >= 2)
        {
        sprintf(log_buf, "Not configured: IS_GPU_STATUS received from %s",
          node->nd_name);

        log_err(ret, id, log_buf);
        }

#endif  /* NVIDIA_GPUS */

      break;


    default:

      sprintf(log_buf, "unknown command %d sent from %s",
        command,
        node->nd_name);

      log_err(-1, id, log_buf);

      goto err;

      break;
    }  /* END switch (command) */

  /* must be closed because mom opens and closes this connection each time */
  close_conn(sock, FALSE);

  unlock_node(node, id, "close", LOGLEVEL);
  
  free(vp);

  return(NULL);

err:

  /* a DIS write error has occurred */

  if (node != NULL)
    {
    if (LOGLEVEL >= 1)
      {
      DBPRT(("%s: error processing node %s\n",
            id,
            node->nd_name))
      }

    sprintf(log_buf, "%s from %s(%s)",
      dis_emsg[ret],
      node->nd_name,
      netaddr(addr));
    
    unlock_node(node, id, "err", LOGLEVEL);
    }
  else
    {
    sprintf(log_buf,"%s occurred when trying to read sock %d",
      dis_emsg[ret],
      sock);
    }
    
  log_err(-1, id, log_buf);
    
  close_conn(sock, FALSE);
    
  free(vp);

  return(NULL);
  } /* END is_request_work */






/*
 * Input is coming from the pbs_mom over a DIS tcp stream.
 * Read the stream to get a Inter-Server request.
 */

void is_request(

  int  stream,  /* I */
  int  version) /* I */

  {
  int *args;
  int rc;

  static char id[] = "is_request";

  args = (int *)calloc(2, sizeof(int));

  if (args == NULL)
    {
    log_err(ENOMEM,id,"Cannot allocate memory...system failure inevitable");
    return;
    }

  args[0] = stream;
  args[1] = version;

  rc = enqueue_threadpool_request(is_request_work,args);

  if (rc)
    {
    log_err(rc,id,"Unable to enqueue is request task into the threadpool");
    }
  }  /* END is_request() */





void *write_node_state_work(

  void *vp)

  {
  char id[] = "write_node_state_work";
  struct pbsnode *np;
  static char    *fmt = "%s %d\n";
  static FILE    *nstatef = NULL;
  int             iter = -1;

  int   savemask;

  pthread_mutex_lock(node_state_mutex);

  if (LOGLEVEL >= 5)
    {
    DBPRT(("write_node_state_work: entered\n"))
    }

  /* don't store volatile states like down and unknown */

  savemask = INUSE_OFFLINE | INUSE_RESERVE;

  if (nstatef != NULL)
    {
    fseek(nstatef, 0L, SEEK_SET); /* rewind and clear */

    if (ftruncate(fileno(nstatef), (off_t)0) != 0)
      {
      log_err(errno, id, "could not truncate file");

      pthread_mutex_unlock(node_state_mutex);
      
      return(NULL);
      }
    }
  else
    {
    /* need to open for first time, temporary-move to pbsd_init */

    if ((nstatef = fopen(path_nodestate, "w+")) == NULL)
      {
      log_err( errno, id, "could not open file");

      pthread_mutex_unlock(node_state_mutex);
      
      return(NULL);
      }
    }

  /*
  ** The only state that carries forward is if the
  ** node has been marked offline.
  */

  while ((np = next_host(&allnodes,&iter,NULL)) != NULL)
    {
    if (!(np->nd_state & INUSE_OFFLINE))
      {
      fprintf(nstatef, fmt, np->nd_name, np->nd_state & savemask);
      }

    unlock_node(np, id, NULL, LOGLEVEL);
    } /* END for each node */

  if (fflush(nstatef) != 0)
    {
    log_err(errno, id, "failed saving node state to disk");
    }

  fclose(nstatef);
  nstatef = NULL;

  pthread_mutex_unlock(node_state_mutex);

  return(NULL);
  } /* END write_node_state_work() */





void write_node_state(void)

  {
  static char id[] = "write_node_state";
  int rc = enqueue_threadpool_request(write_node_state_work,NULL);

  if (rc)
    {
    log_err(rc,id,"Unable to enqueue is_request task into the threadpool");
    }
  }  /* END write_node_state() */



/* Create a new node_note file then overwrite the previous one.
 *
 *   The note file could get up to:
 *      (# of nodes) * (2 + MAX_NODE_NAME + MAX_NOTE)  bytes in size
 */
int write_node_note(void)

  {
  static char id[] = "write_node_note";

  struct pbsnode *np;
  int             iter = -1;
  FILE           *nin;

  if (LOGLEVEL >= 2)
    {
    DBPRT(("%s: entered\n",
           id))
    }

  if ((nin = fopen(path_nodenote_new, "w")) == NULL)
    goto err1;

  if ((svr_totnodes == 0))
    {
    log_event(
      PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, "Server has empty nodes list");

    fclose(nin);

    return(-1);
    }

  /* for each node ... */
  while ((np = next_host(&allnodes, &iter, NULL)) != NULL)
    {
    /* write node name followed by its note string */
    if (np->nd_note != NULL && np->nd_note != '\0')
      {
      fprintf(nin, "%s %s\n", np->nd_name, np->nd_note);
      }
    
    unlock_node(np, id, NULL, LOGLEVEL);
    }

  fflush(nin);

  if (ferror(nin))
    {
    fclose(nin);
    goto err1;
    }

  fclose(nin);

  if (rename(path_nodenote_new, path_nodenote) != 0)
    {
    log_event(
      PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id,
      "replacing old node note file failed");

    return(-1);
    }

  return(PBSE_NONE);

err1:
  log_event(
    PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, "Node note file update failed");

  return(-1);
  }  /* END write_node_note() */



/*
 * free_prop - free list of prop structures created by proplist()
 */

static void free_prop(

  struct prop *prop)

  {

  struct prop *pp;

  for (pp = prop;pp != NULL;pp = prop)
    {
    prop = pp->next;

    free(pp->name);
    free(pp);
    }  /* END for (pp) */

  return;
  }    /* END free_prop() */




void *node_unreserve_work(

  void *vp)

  {
  resource_t handle = *((resource_t *)vp);

  struct  pbsnode *np;

  struct  pbssubn *sp;
  int              iter = -1;

  /* clear old reserve */
  while ((np = next_host(&allnodes,&iter,NULL)) != NULL)
    {
    for (sp = np->nd_psn;sp;sp = sp->next)
      {
      if (sp->inuse & INUSE_RESERVE)
        {
        if ((handle == RESOURCE_T_ALL) || (handle == sp->allocto))
          {
          np->nd_nsnfree++;
          
          sp->inuse    &= ~INUSE_RESERVE;
          np->nd_state &= ~INUSE_RESERVE;
          }
        }
      }

    unlock_node(np, "node_unreserve_work", NULL, LOGLEVEL);
    }

  return(NULL);
  } /* END node_unreserve_work() */





/*
 * unreserve - unreserve nodes
 *
 * If handle is set to a existing resource_t, then release all nodes
 * associated with that handle, otherwise, (this is dangerous)
 * if handle == RESOURCE_T_ALL, release all nodes period.
 */

void node_unreserve(

  resource_t handle)

  {
  static char id[] = "node_unreserve";
  int rc = enqueue_threadpool_request(node_unreserve_work,NULL);

  if (rc)
    {
    log_err(rc,id,"Unable to enqueue node_unreserve task into the threadpool");
    }
  }  /* END node_unreserve() */




/*
** Look through the property list and make sure that all
** those marked are contained in the node.
*/

int hasprop(

  struct pbsnode *pnode,
  struct prop    *props)

  {

  struct  prop    *need;

  for (need = props;need;need = need->next)
    {

    struct prop *pp;

    if (need->mark == 0) /* not marked, skip */
      continue;

    for (pp = pnode->nd_first;pp != NULL;pp = pp->next)
      {
      if (strcmp(pp->name, need->name) == 0)
        break;  /* found it */
      }

    if (pp == NULL)
      {
      return(0);
      }
    }

  return(1);
  }  /* END hasprop() */





/*
 * see if node has the number of processors required
 * if free == SKIP_NONE,  check against total number of processors, else
 * if free != SKIP_NONE,  check against number free
 *
 * Return 1 if possible, 0 if not
 */

static int hasppn(

  struct pbsnode *pnode,     /* I */
  int             node_req,  /* I */
  int             free)      /* I */

  {
  if ((free != SKIP_NONE) &&
      (free != SKIP_NONE_REUSE) &&
      (pnode->nd_nsnfree >= node_req))
    {
    return(1);
    }

  if ((free == SKIP_NONE) && 
      (pnode->nd_nsn >= node_req))
    {
    return(1);
    }

  return(0);
  }  /* END hasppn() */




/*
** Count how many gpus are available for use on this node
*/
static int gpu_count(

  struct pbsnode *pnode,  /* I */
  int    freeonly)        /* I */

  {
  static char id[] = "gpu_count";
  int  count = 0;
  char log_buf[LOCAL_LOG_BUF_SIZE];

  if ((pnode->nd_state & INUSE_OFFLINE) ||
      (pnode->nd_state & INUSE_UNKNOWN) ||
      (pnode->nd_state & INUSE_DOWN))
    {
    if (LOGLEVEL >= 7)
      {
      sprintf(log_buf,
        "Counted %d gpus %s on node %s that was skipped",
        count,
        (freeonly? "free":"available"),
        pnode->nd_name);

		  log_ext(-1, id, log_buf, LOG_DEBUG);
      }
    return (count);
    }

#ifdef NVIDIA_GPUS
  if (pnode->nd_gpus_real)
    {
    int j;

    for (j = 0; j < pnode->nd_ngpus; j++)
      {
      struct gpusubn *gn = pnode->nd_gpusn + j;

      /* always ignore unavailable gpus */
      if (gn->state == gpu_unavailable)
        continue;

      if (!freeonly)
        {
        count++;
        }
      else if ((gn->state == gpu_unallocated) ||
            ((gn->state == gpu_shared) && (gpu_mode_rqstd == gpu_normal)))
        {
        count++;;
        }
      }
    }
  else
#endif  /* NVIDIA_GPUS */
    {
    /* virtual gpus */
    if (freeonly)
      {
      count = pnode->nd_ngpus_free;
      }
    else
      {
      count = pnode->nd_ngpus;
      }
    }

  if (LOGLEVEL >= 7)
    {
    sprintf(log_buf,
      "Counted %d gpus %s on node %s",
      count,
      (freeonly? "free":"available"),
      pnode->nd_name);

	  log_ext(-1, id, log_buf, LOG_DEBUG);
    }

  return(count);
  }  /* END gpu_count() */





#ifdef NVIDIA_GPUS
/*
** get gpu index for this gpuid
*/
int gpu_entry_by_id(

  struct pbsnode *pnode,  /* I */
  char   *gpuid,
  int    get_empty)

  {

  if (pnode->nd_gpus_real)
    {
    int j;

    for (j = 0; j < pnode->nd_ngpus; j++)
      {
      struct gpusubn *gn = pnode->nd_gpusn + j;

      if ((gn->gpuid != NULL) && (strcmp(gpuid, gn->gpuid) == 0))
        {
        return(j);
        }
      }
    }

  /*
   * we did not find the entry.  if get_empty is set then look for an empty
   * slot.  If none is found then try to add a new entry to nd_gpusn
   */

  if (get_empty)
    {
    int j;

    for (j = 0; j < pnode->nd_ngpus; j++)
      {
      struct gpusubn *gn = pnode->nd_gpusn + j;

      if (gn->gpuid == NULL)
        {
        return(j);
        }
      }

    create_a_gpusubnode(pnode);
    return (pnode->nd_ngpus - 1);    
    }

  return (-1);
  }  /* END gpu_entry_by_id() */
#endif  /* NVIDIA_GPUS */





/*
 * checks if a node is ok for to reshuffle
 *
 * All parameters are exactly the same as search
 * @param pnode - the node we're looking at
 *
 * @return TRUE if the node is reshuffleable for search's purposes
 */
int can_reshuffle(

  struct pbsnode *pnode,
  struct prop    *glorf,
  int             skip,
  int             vpreq,
  int             gpureq,
  int             pass)

  {
  static char id[] = "can_reshuffle";

  char log_buf[LOCAL_LOG_BUF_SIZE];

  if (pnode->nd_ntype == NTYPE_CLUSTER)
    {
    if (pnode->nd_flag != thinking)
      {
      /* only shuffle nodes which have been selected above */

      return(FALSE);
      }

    if (pnode->nd_state & pass)
      return(FALSE);

    if (LOGLEVEL >= 6)
      {
      sprintf(log_buf,
        "search(2): starting eval gpus on node %s need %d(%d) mode %d has %d free %d skip %d",
        pnode->nd_name,
        gpureq,
        pnode->nd_ngpus_needed,
        gpu_mode_rqstd,
        pnode->nd_ngpus,
        gpu_count(pnode, TRUE),
        skip);

       log_ext(-1, id, log_buf, LOG_DEBUG);
       }

    if ((skip == SKIP_EXCLUSIVE) && 
        (vpreq < pnode->nd_nsnfree) &&
        (gpureq < gpu_count(pnode, TRUE)))
      return(FALSE);

    if ((skip == SKIP_ANYINUSE) &&
        (vpreq < (pnode->nd_nsnfree + pnode->nd_nsnshared)) &&
        (gpureq < gpu_count(pnode, TRUE)))
      return(FALSE);

    if (!hasprop(pnode, glorf))
      return(FALSE);
    }
  else
    return(FALSE);

  return(TRUE);
  } /* can_reshuffle() */





/*
** Parse a number in a spec.
** Return 0 if okay, 1 if no number exists, -1 on error
*/

static int number(

  char **ptr,
  int   *num)

  {
  char  holder[80];
  int   i = 0;
  char *str = *ptr;
  char  log_buf[LOCAL_LOG_BUF_SIZE];

  while (isdigit(*str) && (unsigned int)(i + 1) < sizeof holder)
    holder[i++] = *str++;

  if (i == 0)
    {
    return(1);
    }

  holder[i] = '\0';

  if ((i = atoi(holder)) <= 0)
    {
    sprintf(log_buf, "zero illegal");

    return(-1);
    }

  *ptr = str;

  *num = i;

  return(0);
  }  /* END number() */




/*
** Check string to see if it is a legal property name.
** If not, return 1.
** *prop set to static char array containing the properity,
** must be copied.
*/

static int property(

  char **ptr,
  char **prop)

  {
  char        *str = *ptr;
  char        *dest = *prop;
  int          i = 0;
  char         log_buf[LOCAL_LOG_BUF_SIZE];

  if (!isalpha(*str))
    {
    sprintf(log_buf, "first character of property (%s) not a letter", str);

    return(1);
    }

  while (isalnum(*str) || *str == '-' || *str == '.' || *str == '=' || *str == '_')
    dest[i++] = *str++;

  dest[i] = '\0';

  /* skip over "/vp_number" */

  if (*str == '/')
    {
    do
      {
      str++;
      }
    while (isdigit(*str));
    }

  *ptr = str;

  return(0);
  }  /* END property() */





/*
** Create a property list from a string.
** Return 0 if all is well, 1 otherwise.
*/

static int proplist(

  char  **str,
  struct prop **plist,
  int   *node_req,
  int   *gpu_req)

  {

  struct prop *pp;
  char         name_storage[80];
  char        *pname;
  char        *pequal;
#ifdef NVIDIA_GPUS
  static char  id[] = "proplist";
  int          have_gpus = FALSE;
  char         log_buf[LOCAL_LOG_BUF_SIZE];
#endif  /* NVIDIA_GPUS */

  *node_req = 1; /* default to 1 processor per node */

  pname  = name_storage;
  *pname = '\0';

  for (;;)
    {
    if (property(str, &pname))
      {
      return(1);
      }

    if (*pname == '\0')
      break;

    if ((pequal = strchr(pname, (int)'=')) != NULL)
      {
      /* special property */

      /* identify the special property and place its value */
      /* into node_req       */

      *pequal = '\0';

      if (strcmp(pname, "ppn") == 0)
        {
        pequal++;

        if ((number(&pequal, node_req) != 0) || (*pequal != '\0'))
          {
          return(1);
          }
        }
      else if (strcmp(pname, "gpus") == 0)
        {
        pequal++;

        if ((number(&pequal, gpu_req) != 0) || (*pequal != '\0'))
          {
          return(1);
          }
#ifdef NVIDIA_GPUS
        have_gpus = TRUE;
        gpu_err_reset = FALSE; /* default to no */
#endif  /* NVIDIA_GPUS */

        /* default value if no other gets specified */

        gpu_mode_rqstd = gpu_exclusive_thread;
        }
      else
        {
        return(1); /* not recognized - error */
        }
      }
#ifdef NVIDIA_GPUS
    else if (have_gpus && (!strcasecmp(pname, "exclusive_thread")))
      {
      gpu_mode_rqstd = gpu_exclusive_thread;
      }
    else if (have_gpus && (!strcasecmp(pname, "exclusive")))
      {
      gpu_mode_rqstd = gpu_exclusive_thread;
      }
    else if (have_gpus && (!strcasecmp(pname, "exclusive_process")))
      {
      gpu_mode_rqstd = gpu_exclusive_process;
      }
    else if (have_gpus && (!strcasecmp(pname, "default")))
      {
      gpu_mode_rqstd = gpu_normal;
      }
    else if (have_gpus && (!strcasecmp(pname, "shared")))
      {
      gpu_mode_rqstd = gpu_normal;
      }
    else if (have_gpus && (!strcasecmp(pname, "reseterr")))
      {
      gpu_err_reset = TRUE;
      }
#endif  /* NVIDIA_GPUS */
    else
      {
      pp = (struct prop *)calloc(1, sizeof(struct prop));

      pp->mark = 1;
      pp->name = strdup(pname);
      pp->next = *plist;

      *plist = pp;
      }

#ifdef NVIDIA_GPUS
    if ((have_gpus) && (LOGLEVEL >= 7))
      {
      sprintf(log_buf,
        "proplist: set needed gpu mode to %d",
        gpu_mode_rqstd);

       log_ext(-1, id, log_buf, LOG_DEBUG);
      }
#endif  /* NVIDIA_GPUS */

    if (**str != ':')
      break;

    (*str)++;
    }  /* END for(;;) */

  return(PBSE_NONE);
  }  /* END proplist() */




/*
** Add the "global" spec to every sub-spec in "spec".
**      RETURNS:  allocated string buffer (must be freed externally)
*/

static char *mod_spec(

  char *spec,    /* I */
  char *global)  /* I */

  {
  char  *line;
  char *cp;
  int    len;
  int    nsubspec;

  nsubspec = 1;

  for (cp = spec;*cp != '\0';cp++)
    {
    if (*cp == '+')
      {
      nsubspec++;
      }
    }

  len = strlen(global);

  line = calloc(1, nsubspec * (len + 1) + strlen(spec) + 1);

  if (line == NULL)
    {
    /* FAILURE */

    return(NULL);
    }

  cp = line;

  while (*spec)
    {
    if (*spec == '+')
      {
      *cp++ = ':';

      strcpy(cp, global);

      cp += len;
      }

    *cp++ = *spec++;
    }

  *cp++ = ':';

  strcpy(cp, global);

  return(line);
  }  /* END mod_spec() */




/* cntjons - count jobs on (shared) nodes */
/*
static int cntjons(

  struct pbsnode *pn)

  {

  struct pbssubn *psn;
  int ct = 0;
  int n;

  struct jobinfo *pj;

  psn = pn->nd_psn;

  for (n = 0;n < pn->nd_nsn;++n)
    {
    pj = psn->jobs;

    while (pj)
      {
      ++ct;

      pj = pj->next;
      }

    psn = psn->next;
    }

  return(ct);
  }
*/



/*
 * nodecmp - compare two nodes for sorting
 * For "exclusive", depending on setting of node_order attribute:
 *     pack:    put free node with fewest non-zero free VPs in node first
 *     scatter: put free node with most fre VPs first
 * For "shared", put current shared with fewest jobs first,
 *  then free nodes, and others last
 */


#define BIG_NUM 32768 /* used only in nodecmp() */

/*
static int nodecmp(

  const void *aa,
  const void *bb)

  {

  struct pbsnode *a = *(struct pbsnode **)aa;

  struct pbsnode *b = *(struct pbsnode **)bb;
  int aprim, bprim;
*/
  /* exclusive is global */
/*
  if (exclusive)
    {
*/    /* best is free */
/*
    if (server.sv_attr[SRV_ATR_NodePack].at_val.at_long)
      {
*/      /* pack - fill up nodes first */
/*
      aprim = (a->nd_nsnfree > 0) ? a->nd_nsnfree : BIG_NUM;

      bprim = (b->nd_nsnfree > 0) ? b->nd_nsnfree : BIG_NUM;
      }
    else
      {
*/      /* scatter - spread amoung nodes first */
/*
      aprim = a->nd_nsn - a->nd_nsnfree;
      bprim = b->nd_nsn - b->nd_nsnfree;
      }
    }
  else
    {
*/    /* best is shared with fewest jobs */
/*
    aprim = (a->nd_state == INUSE_JOBSHARE) ?
            cntjons(a) :
            ((a->nd_state == INUSE_FREE) ? 5 : 1000);

    bprim = (b->nd_state == INUSE_JOBSHARE) ?
            cntjons(b) :
            ((b->nd_state == INUSE_FREE) ? 5 : 1000);
    }

  if (aprim == bprim)
    {
    return(a->nd_nprops - b->nd_nprops);
    }

  return (aprim - bprim);
  }*/  /* END nodecmp() */




int MSNPrintF(

  char **BPtr,   /* I */
  int   *BSpace, /* I */
  char  *Format, /* I */
  ...)           /* I */

  {
  int len;

  va_list Args;

  if ((BPtr == NULL) ||
      (BSpace == NULL) ||
      (Format == NULL) ||
      (*BSpace <= 0))
    {
    return(FAILURE);
    }

  va_start(Args,Format);

  len = vsnprintf(*BPtr,*BSpace,Format,Args);

  va_end(Args);

  if (len <= 0)
    {
    return(FAILURE);
    }
  
  if (len >= *BSpace)
    {
    /* truncation occurred due to attempted
     * overflow! */

    /* do not place BPtr past the end of the buffer:
     * it is too dangerous (calling function could derference it
     * to check for empty string, etc.)! */

    *BPtr += (*BSpace) - 1;
    *BSpace = 0;

    return(FAILURE);
    }
  
  *BPtr += len;
  *BSpace -= len;

  return(SUCCESS);
  }  /* END MSNPrintF() */


/*
 * Test a procs specification.
 *
 * Return >0 - number of procs counted in the spec if it works,
 *         0 - if it cannot be satisfied now,
 *        -1 - if it can never be satisfied.
 *
 */
int procs_available(
    
  int proc_ct)

  {
  int             iter = -1;
  int             procs_avail = 0;
  struct pbsnode *pnode;

  if (proc_ct > svr_clnodes)
    {
    /* user requested more processors than are available on the system*/
    return(-1);
    }

  while ((pnode = next_host(&allnodes,&iter,NULL)) != NULL)
    {
    procs_avail += pnode->nd_nsnfree;

    unlock_node(pnode, "procs_available", NULL, LOGLEVEL);
    }

  if (proc_ct > procs_avail)
    {
    return(0);
    }

  return(procs_avail);
  } /* END procs_available() */




int node_is_spec_acceptable(

  struct pbsnode   *pnode,
  single_spec_data *spec,
  char             *ProcBMStr,
  int               exclusive,
  int              *eligible_nodes)

  {
  static char    *id = "node_is_spec_acceptable";
  struct pbssubn *snp;
  struct prop    *prop = spec->prop;

  int             ppn_req = spec->ppn;
  int             gpu_req = spec->gpu;

#ifdef GEOMETRY_REQUESTS
  if (IS_VALID_STR(ProcBMStr))
    {
    if (pnode->nd_state != INUSE_FREE)
      return(FALSE);

    if (node_satisfies_request(pnode, ProcBMStr) == FALSE)
      return(FALSE);
    }
#endif

  /* NYI: check if these are necessary */
  pnode->nd_flag = okay;

  for (snp = pnode->nd_psn; snp != NULL; snp = snp->next)
    {
    snp->flag = okay;

  if (LOGLEVEL >= 9)
    DBPRT(("%s: %s/%d inuse 0x%x nprops %d\n",
      id,
      pnode->nd_name,
      snp->index,
      snp->inuse,
      pnode->nd_nprops))
    }

  if (pnode->nd_ntype != NTYPE_CLUSTER)
    return(FALSE);

  /* make sure that the node has properties */
  if (hasprop(pnode, prop) == FALSE)
    return(FALSE);

  if ((hasppn(pnode, ppn_req, SKIP_NONE) == FALSE) ||
      (gpu_count(pnode, FALSE) < gpu_req))
    return(FALSE);

  (*eligible_nodes)++;

  if ((pnode->nd_state & (INUSE_OFFLINE | INUSE_DOWN | INUSE_RESERVE | INUSE_JOB)) != 0)
    return(FALSE);

  if (exclusive == TRUE) 
    {
    int gpu_free = gpu_count(pnode, TRUE) - pnode->nd_ngpus_to_be_used;
    int np_free  = pnode->nd_nsnfree - pnode->nd_np_to_be_used;

    if ((ppn_req > np_free) ||
        (gpu_req > gpu_free))
      return(FALSE);
    }

  return(TRUE);
  } /* END node_is_spec_acceptable() */




int parse_req_data(
    
  complete_spec_data *all_reqs)

  {
  int               i;
  int               j;

  single_spec_data *req;

  for (i = 0; i < all_reqs->num_reqs; i++)
    {
    req = all_reqs->reqs + i;
    req->nodes = 1;
    req->gpu   = 0;
    req->ppn   = 1;
    req->prop  = NULL;

    if ((j = number(&(all_reqs->req_start[i]), &(req->nodes))) == -1)
      return(j);

    if (j == 0)
      {
      /* there was a number */
      if (*(all_reqs->req_start[i]) != '\0')
        {
        if (*(all_reqs->req_start[i]) == ':')
          all_reqs->req_start[i]++;
        
        if (proplist(&(all_reqs->req_start[i]), &(req->prop), &(req->ppn), &(req->gpu)))
          return(-1);
        }
      }
    else
      {
      if (*(all_reqs->req_start[i]) != '\0')
        {
        if (proplist(&(all_reqs->req_start[i]), &(req->prop), &(req->ppn), &(req->gpu)))
          return(-1);
        }
      }
    }

  return(PBSE_NONE);
  } /* END parse_req_data() */




/* 
 * builds the node_job_add_info struct that will be used by set_nodes
 * instead of looping over different nodes.
 */

int save_node_for_adding(
    
  node_job_add_info *naji,
  struct pbsnode    *pnode,
  single_spec_data  *req,
  char              *first_node_name)

  {
  static char       *id = "save_node_for_adding";
  node_job_add_info *to_add;
  node_job_add_info *old_next;

  if ((first_node_name[0] != '\0') &&
      (!strcmp(first_node_name, pnode->nd_name)))
    pnode->nd_order = 0;
  else
    pnode->nd_order = 1;

  if (naji->node_name[0] == '\0')
    {
    /* first */
    strcpy(naji->node_name, pnode->nd_name);
    naji->ppn_needed = req->ppn;
    naji->gpu_needed = req->gpu;
    }
  else
    {
    /* second */
    if ((to_add = calloc(1, sizeof(node_job_add_info))) == NULL)
      {
      log_err(ENOMEM, id, "Cannot allocate memory!");

      return(ENOMEM);
      }
    
    /* initialize to_add */
    strcpy(to_add->node_name, pnode->nd_name);
    to_add->ppn_needed = req->ppn;
    to_add->gpu_needed = req->gpu;

    /* fix pointers, NOTE: works even if old_next == NULL */
    old_next = naji->next;
    to_add->next = old_next;
    naji->next = to_add;
    }

  /* count off the number we have reserved */
  pnode->nd_np_to_be_used    += req->ppn;
  pnode->nd_ngpus_to_be_used += req->gpu;

  return(PBSE_NONE);
  } /* END save_node_for_adding */




/*
 * if there is a node being requested, the spec should look like
 * node_name[:ppn=X][+]...
 * otherwise it should look like:
 * <NUM_NODES>[:ppn=X][+]...
 *
 * If a specific node is being requested first, copy just the
 * name into first_node_name  
 */

void set_first_node_name(
    
  char *spec_param,      /* I */
  char *first_node_name) /* O */

  {
  int   i;
  int   len;

  if (isdigit(spec_param[0]) == TRUE)
    {
    first_node_name[0] = '\0';
    }
  else
    {
    len = strlen(spec_param);
    
    for (i = 0; i < len; i++)
      {
      /* a ':' means you've moved on to ppn and a + means its the next req */
      if ((spec_param[i] == ':') ||
          (spec_param[i] == '+'))
        break;
      else
        first_node_name[i] = spec_param[i];
      }
    
    /* make sure you NULL terminate */
    first_node_name[i] = '\0';
    }

  } /* END set_first_node_name() */

void release_node_allocation(node_job_add_info *naji)
  {
  node_job_add_info *current = NULL;
  struct pbsnode    *pnode = NULL;

  current = naji;
  while (current != NULL) 
    {
    if ((pnode = find_nodebyname(current->node_name)) != NULL)
      {
      pnode->nd_np_to_be_used    -= current->ppn_needed;
      pnode->nd_ngpus_to_be_used -= current->gpu_needed;
      unlock_node(pnode, __func__, NULL, LOGLEVEL);
      }
    current = current->next;
    }
  }


/*
 * Test a node specification.
 *
 * Return >0 - number of nodes counted in the spec if it works,
 *         0 - if it cannot be satisfied,
 *        -1 - if it can never be satisfied.
 * Okay to bail early if "early" is true.
 * VPs selected are marked "thinking"
 */

static int node_spec(

  char              *spec_param, /* I */
  int                early,      /* I (boolean) */
  int                exactmatch, /* I (boolean) - NOT USED */
  char              *ProcBMStr,  /* I */
  char              *FailNode,   /* O (optional,minsize=1024) */
  node_job_add_info *naji,       /* O (optional) */
  char              *EMsg)       /* O (optional,minsize=1024) */

  {
  static char         id[] = "node_spec";
  static char         shared[] = "shared";

  struct pbsnode     *pnode;
  char                first_node_name[PBS_MAXHOSTNAME + 1];
  node_iterator       iter;
  char                log_buf[LOCAL_LOG_BUF_SIZE];

  char               *str;
  char               *globs;
  char               *cp;
  char               *hold;
  int                 i;
  int                 num;
  int                 rc;
  int                 eligible_nodes = 0;
  complete_spec_data  all_reqs;
  char               *spec;
  char               *plus;

  extern int PNodeStateToString(int, char *, int);

  if (EMsg != NULL)
    EMsg[0] = '\0';

  if (FailNode != NULL)
    FailNode[0] = '\0';

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buf, "entered spec=%.4000s", spec_param);

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);

    DBPRT(("%s\n", log_buf));
    }

  exclusive = 1; /* by default, nodes (VPs) are requested exclusively */

  set_first_node_name(spec_param, first_node_name);

  spec = strdup(spec_param);

  if (spec == NULL)
    {
    /* FAILURE */
    sprintf(log_buf,"cannot alloc memory");

    if (LOGLEVEL >= 1)
      {
      log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
      }

    if (EMsg != NULL)
      {
      snprintf(EMsg, 1024, "%s", log_buf);
      }

    return(-1);
    }

  if ((globs = strchr(spec, '#')) != NULL)
    {
    *globs++ = '\0';

    globs = strdup(globs);

    while ((cp = strrchr(globs, '#')) != NULL)
      {
      *cp++ = '\0';

      if (strcmp(cp, shared) != 0)
        {
        hold = mod_spec(spec, cp);

        free(spec);

        spec = hold;
        }
      else
        {
        exclusive = 0;
        }
      }

    if (strcmp(globs, shared) != 0)
      {
      hold = mod_spec(spec, globs);

      free(spec);

      spec = hold;
      }
    else
      {
      exclusive = 0;
      }

    free(globs);
    }  /* END if ((globs = strchr(spec,'#')) != NULL) */

  str = spec;

  num = ctnodes(str);

#ifndef CRAY_MOAB_PASSTHRU
  if (num > svr_clnodes)
    {
    /* FAILURE */

    free(spec);

    sprintf(log_buf, "job allocation request exceeds available cluster nodes, %d requested, %d available",
      num,
      svr_clnodes);

    if (LOGLEVEL >= 6)
      {
      log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
      }

    if (EMsg != NULL)
      {
      snprintf(EMsg, 1024, "%s", log_buf);
      }

    return(-1);
    }
#endif

  all_reqs.total_nodes = num;
  all_reqs.num_reqs = 1;
  plus = spec;

  /* count number of reqs */
  while ((plus = strchr(plus + 1, '+')) != NULL)
    all_reqs.num_reqs++;

  /* allocate space in all_reqs */
  all_reqs.reqs      = calloc(all_reqs.num_reqs, sizeof(single_spec_data));
  all_reqs.req_start = calloc(all_reqs.num_reqs, sizeof(char *));

  if ((all_reqs.reqs == NULL) ||
      (all_reqs.req_start == NULL))
    {
    log_err(ENOMEM, id, "Cannot allocate memory!");
    return(-1);
    }

  /* set up pointers for reqs */
  plus = spec;
  i = 0;
  all_reqs.req_start[i] = spec;
  i++;

  while ((plus = strchr(plus + 1, '+')) != NULL)
    {
    /* make the '+' NULL and advance past it */
    *plus = '\0';
    plus++;

    /* advance past "nodes=" */
    if (!strncmp(plus, "nodes=", strlen("nodes=")))
      plus += strlen("nodes=");

    all_reqs.req_start[i] = plus;
    i++;
    }

  /* now parse each spec into the data */
  if ((rc = parse_req_data(&all_reqs)) != PBSE_NONE)
    {
    /* FAILURE */
    free(all_reqs.reqs);
    free(all_reqs.req_start);

    return(rc);
    }

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buf, "job allocation debug: %d requested, %d svr_clnodes, %d svr_totnodes",
      num,
      svr_clnodes,
      svr_totnodes);

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);

    DBPRT(("%s\n",
      log_buf));
    }

  /*
   * if SRV_ATR_NodePack set (true or false), then
   * sort nodes by state, number of VPs and number of attributes;
   * otherwise, leave unsorted
   */

  /*
  if (server.sv_attr[SRV_ATR_NodePack].at_flags & ATR_VFLAG_SET)
    {
    qsort(pbsndlist, svr_totnodes, sizeof(struct pbsnode *), nodecmp);
    }
    */

  reinitialize_node_iterator(&iter);
  pnode = NULL;

  /* iterate over all nodes */
  while ((pnode = next_node(&allnodes,pnode,&iter)) != NULL)
    {
    /* check each req against this node to see if it satisfies it */
    for (i = 0; i < all_reqs.num_reqs; i++)
      {
      single_spec_data *req = all_reqs.reqs + i;

      if (req->nodes > 0)
        {
        if (node_is_spec_acceptable(pnode, req, ProcBMStr, exclusive, &eligible_nodes) == TRUE)
          {
          if (naji != NULL)
            {
            save_node_for_adding(naji, pnode, req, first_node_name);
            }

          /* decrement needed nodes */
          all_reqs.total_nodes--;
          req->nodes--;
    
          /* are all reqs satisfied? */
          if (all_reqs.total_nodes == 0)
            break;
          }
        }
      }

    /* are all reqs satisfied? */
    if (all_reqs.total_nodes == 0)
      {
      unlock_node(pnode, id, NULL, LOGLEVEL);
      break;
      }
    } /* END for each node */

  free(all_reqs.reqs);
  free(all_reqs.req_start);
  free(spec);

#ifndef CRAY_MOAB_PASSTHRU
  if (eligible_nodes < num)
    {
    /* sufficient eligible nodes do not exist */
    /* FAILURE */
    sprintf(log_buf,
      "job requesting nodes that will never be available - spec = %s",
      spec_param);

    log_err(-1, id, log_buf);
    if (naji != NULL)
      release_node_allocation(naji);

    return(-1);
    }
#endif

  if (all_reqs.total_nodes > 0)
    {
    /* nodes no currently available */
    /* FAILURE */
    sprintf(log_buf,
      "job allocation request exceeds currently available cluster nodes, %d requested, %d available",
      num,
      num - all_reqs.total_nodes);

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);

    if (EMsg != NULL)
      {
      snprintf(EMsg, MAXLINE, "%s", log_buf);
      }
    if (naji != NULL)
      release_node_allocation(naji);

    return(0);
    } /* END if (all_reqs.total_nodes > 0) */

  /* SUCCESS - spec is ok */
  if (LOGLEVEL >= 6)
    {
    sprintf(log_buf, "job allocation debug(3): returning %d requested", num);

    log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buf);

    DBPRT(("%s\n", log_buf));
    }

  return(num);
  }  /* END node_spec() */




#ifdef GEOMETRY_REQUESTS
/**
 * get_bitmap
 *
 * @param pjob (I) - the job whose bitmap is be retrieved
 * @param ProcBMPtr (O) - the ptr to the string where the bitmap will be stored
 * @param ProcBMSize (I) - the size of the string ProcBMPtr points to
 * @return FAILURE if there is no specified bitmap or either pjob or ProcBMStrPtr are NULL
 * @return SUCCESS otherwise
 */
int get_bitmap(

  job  *pjob,        /* I */
  int   ProcBMSize,  /* I */
  char *ProcBMPtr)   /* O */

  {
  resource     *presc;
  resource_def *prd;

  char          LocalBM[MAX_BM];

  if ((pjob == NULL) ||
      (ProcBMPtr == NULL))
    {
    return(FAILURE);
    }

  LocalBM[0] = '\0';

  /* read the bitmap from the resource list */
  prd = find_resc_def(svr_resc_def,"procs_bitmap",svr_resc_size);
  presc = find_resc_entry(&pjob->ji_wattr[JOB_ATR_resource],prd);
  
  if ((presc != NULL) && 
      (presc->rs_value.at_flags & ATR_VFLAG_SET))
    {
    snprintf(LocalBM,sizeof(LocalBM),"%s",presc->rs_value.at_val.at_str);
    }
  else
    {
    /* fail if there was no bitmap given */

    return(FAILURE);
    }

  if (LocalBM[0] == '\0')
    {
    /* fail if there was no bitmap given */

    return(FAILURE);
    }
  else
    {
    snprintf(ProcBMPtr,sizeof(LocalBM),"%s",LocalBM);
    return(SUCCESS);
    }
  } /* end get_bitmap() */




/**
 * node_satisfies_request
 *
 * @param pnode (I) - the node to check for validity
 * @param ProcBMStr (I) - the bitmap of procs requested
 * @return TRUE - if the node satisfies the bitmap, FALSE otherwise
 * @return BM_ERROR if the bitmap isn't valid
 *
 * NOTE: must always be called by a thread already locking the pnode's mutex
 */
int node_satisfies_request(

  struct pbsnode *pnode,     /* I */
  char           *ProcBMStr) /* I */

  {
  int BMLen;
  int BMIndex;

  struct pbssubn *snp; 

  if (IS_VALID_STR(ProcBMStr) == FALSE)
    return(BM_ERROR);

  /* nodes are exclusive when we're using bitmaps */
  if (pnode->nd_state != INUSE_FREE)
    return(FALSE);

  BMLen = strlen(ProcBMStr);

  /* process in reverse because ProcBMStr[0] referes to core index 0 */
  BMIndex = BMLen-1;

  /* check if the requested processors are available on this node */
  for (snp = pnode->nd_psn;snp && BMIndex >= 0;snp = snp->next)
    {
    /* don't check cores that aren't requested */
    if (ProcBMStr[BMIndex--] != '1')
      continue;

    /* cannot use this node, one of the requested cores is busy */
    if (snp->inuse != INUSE_FREE)
      return(FALSE);
    }

  if (BMIndex >= 0)
    {
    /* this means we didn't finish checking the string -
     * the node doesn't have enough processors */

    return(FALSE);
    }

  /* passed all checks, we're good */
  return(TRUE);
  } /* END node_satisfies_request() */




/**
 * reserve_node
 *
 * @param pnode - node to reserve
 * @param pjob - the job to be added to the node
 * @param hlistptr - a pointer to the host list 
 */

int reserve_node(

  struct pbsnode  *pnode,     /* I/O */
  short            newstate,  /* I */
  job             *pjob,      /* I */
  char            *ProcBMStr, /* I */
  struct howl    **hlistptr)  /* O */

  {
  int BMLen;
  int BMIndex;

  struct pbssubn *snp; 

  if ((pnode == NULL) ||
      (pjob == NULL) ||
      (hlistptr == NULL))
    {
    return(FAILURE);
    }

  BMLen = strlen(ProcBMStr);
  BMIndex = BMLen-1;

  /* now reserve each node */
  for (snp = pnode->nd_psn;snp && BMIndex >= 0;snp = snp->next)
    {
    /* ignore unrequested cores */
    if (ProcBMStr[BMIndex--] != '1')
      continue;

    add_job_to_node(pnode,snp,INUSE_JOB,pjob,exclusive);

    build_host_list(hlistptr,snp,pnode);
    }
  
  /* mark the node as exclusive */
  pnode->nd_state = INUSE_JOB;

  return(SUCCESS);
  }
#endif /* GEOMETRY_REQUESTS */




/**
 * adds this job to the node's list of jobs
 * checks to be sure not to add duplicates
 *
 * conditionally updates the subnode's state
 * decrements the amount of needed nodes
 *
 * @param pnode - the node that the job is running on
 * @param nd_psn - the subnode (processor) that the job is running on
 * @param newstate - the state nodes are transitioning to when used
 * @param pjob - the job that is going to be run
 * @param exclusive - TRUE if jobs are given exclusive node use, FALSE otherwise
 */
int add_job_to_node(

  struct pbsnode *pnode,     /* I/O */
  struct pbssubn *snp,       /* I/O */
  short           newstate,  /* I */
  job            *pjob,      /* I */
  int             exclusive) /* I */

  {
  struct jobinfo *jp;
  char            log_buf[LOCAL_LOG_BUF_SIZE];

  /* NOTE:  search existing job array.  add job only if job not already in place */
  if (LOGLEVEL >= 5)
    {
    sprintf(log_buf, "allocated node %s/%d to job %s (nsnfree=%d)",
      pnode->nd_name,
      snp->index,
      pjob->ji_qs.ji_jobid,
      pnode->nd_nsnfree);

    log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, __func__, log_buf);
    DBPRT(("%s\n", log_buf));
    }

  for (jp = snp->jobs;jp != NULL;jp = jp->next)
    {
    if (!(strcmp(jp->jobid, pjob->ji_qs.ji_jobid)))
      break;
    }

  if (jp == NULL)
    {
    /* add job to front of subnode job array */
    jp = (struct jobinfo *)calloc(1, sizeof(struct jobinfo));

    jp->next = snp->jobs;
    snp->jobs = jp;
    strcpy(jp->jobid, pjob->ji_qs.ji_jobid);

    /* reduce free count */
    pnode->nd_nsnfree--;

    /* if no free VPs, set node state */
    if (pnode->nd_nsnfree <= 0)
      pnode->nd_state = newstate;

    if (snp->inuse == INUSE_FREE)
      {
      snp->inuse = newstate;

      if (!exclusive)
        pnode->nd_nsnshared++;
      }
    }

  /* decrement the amount of nodes needed */
  --pnode->nd_np_to_be_used;

  return(SUCCESS);
  } /* END add_job_to_node() */


    

int add_job_to_gpu_subnode(
    
  struct pbsnode *pnode,
  struct gpusubn *gn,
  job            *pjob)

  {
#ifdef NVIDIA_GPUS
  if (!pnode->nd_gpus_real)
#endif  /* NVIDIA_GPUS */
    {
    /* update the gpu subnode */
    strcpy(gn->jobid, pjob->ji_qs.ji_jobid);
    gn->inuse = TRUE;

    /* update the main node */
    pnode->nd_ngpus_free--;
    }

  pnode->nd_ngpus_to_be_used--;

  return(PBSE_NONE);
  } /* END add_job_to_gpu_subnode() */





/**
 * builds the host list (hlist)
 *
 * @param pnode - the node being added to the host list
 * @param hlist - the host list being built
 */ 
int build_host_list(

  struct howl    **hlistptr,  /* O */
  struct pbssubn  *snp,       /* I */
  struct pbsnode  *pnode)     /* I */
  
  {
  struct howl *curr;
  struct howl *prev;
  struct howl *hp;

  /* initialize the pointers */
  curr = (struct howl *)calloc(1, sizeof(struct howl));
  curr->order = pnode->nd_order;
  curr->name  = pnode->nd_name;
  curr->index = snp->index;
  curr->port = pnode->nd_mom_rm_port;

  /* find the proper place in the list */
  for (prev = NULL, hp = *hlistptr;hp;prev = hp, hp = hp->next)
    {
    if (curr->order <= hp->order)
      break;
    }  /* END for (prev) */

  /* set the correct pointers in the list */
  curr->next = hp;

  if (prev == NULL)
    *hlistptr = curr;
  else
    prev->next = curr;

  return(SUCCESS);
  }





int add_gpu_to_hostlist(
    
  struct howl    **hlistptr,
  struct gpusubn  *gn,
  struct pbsnode  *pnode)

  {
  struct howl *curr;
  struct howl *prev;
  struct howl *hp;
  char        *gpu_name;
  static char *gpu = "gpu";

  /* create gpu_name */
  gpu_name = calloc(1, strlen(pnode->nd_name) + strlen(gpu) + 2);
  sprintf(gpu_name, "%s-%s", pnode->nd_name, gpu);


  /* initialize the pointers */
  curr = (struct howl *)calloc(1, sizeof(struct howl));
  curr->order = pnode->nd_order;
  curr->name  = gpu_name;
  curr->index = gn->index;
  curr->port = pnode->nd_mom_rm_port;

  /* find the proper place in the list */
  for (prev = NULL, hp = *hlistptr;hp;prev = hp, hp = hp->next)
    {
    if (curr->order <= hp->order)
      break;
    }  /* END for (prev) */

  /* set the correct pointers in the list */
  curr->next = hp;

  if (prev == NULL)
    *hlistptr = curr;
  else
    prev->next = curr;

  return(SUCCESS);
  } /* END add_gpu_to_hostlist() */



/*
 * checks the gpus of pnode and places them in gpu_list as necessary
 */

int place_gpus_in_hostlist(

  struct pbsnode     *pnode,
  job                *pjob,
  node_job_add_info  *naji,
  struct howl       **gpu_list)

  {
  static char    *id = "place_gpus_in_hostlist";
  int             j;
  struct gpusubn *gn;

  char            log_buf[LOCAL_LOG_BUF_SIZE];

  /* place the gpus in the hostlist as well */
  for (j = 0; j < pnode->nd_ngpus && naji->gpu_needed > 0; j++)
    {
    sprintf(log_buf,
      "node: %s j %d ngpus %d need %d",
      pnode->nd_name,
      j,
      pnode->nd_ngpus,
      pnode->nd_ngpus_needed);
    
    if (LOGLEVEL >= 7)
      {
      log_ext(-1, id, log_buf, LOG_DEBUG);
      }
    DBPRT(("%s\n", log_buf));
    
    gn = pnode->nd_gpusn + j;
    if ((gn->state == gpu_unavailable) ||
#ifdef NVIDIA_GPUS
        ((gn->state == gpu_exclusive) && pnode->nd_gpus_real) ||
        ((pnode->nd_gpus_real) &&
         ((int)gn->mode == gpu_normal) &&
         ((gpu_mode_rqstd != gpu_normal) && (gn->state != gpu_unallocated))) ||
        ((!pnode->nd_gpus_real) && 
         (gn->inuse == TRUE)))
#else
      (gn->inuse == TRUE))
#endif  /* NVIDIA_GPUS */
        continue;
    
    add_job_to_gpu_subnode(pnode,gn,pjob);
    naji->gpu_needed--;
    
    sprintf(log_buf,
      "ADDING gpu %s/%d to exec_gpus still need %d",
      pnode->nd_name,
      j,
      pnode->nd_ngpus_needed);

    if (LOGLEVEL >= 7)
      {
      log_ext(-1, id, log_buf, LOG_DEBUG);
      }
    DBPRT(("%s\n", log_buf));
    
    add_gpu_to_hostlist(gpu_list,gn,pnode);
    
#ifdef NVIDIA_GPUS
    /*
     * If this a real gpu in exclusive/single job mode, or a gpu in default
     * mode and the job requested an exclusive mode then we change state
     * to exclusive so we cannot assign another job to it
     */
    
    if ((pnode->nd_gpus_real) && 
        ((gn->mode == gpu_exclusive_thread) ||
         (gn->mode == gpu_exclusive_process) ||
         ((gn->mode == gpu_normal) && 
          ((gpu_mode_rqstd == gpu_exclusive_thread) ||
           (gpu_mode_rqstd == gpu_exclusive_process)))))
      {
      gn->state = gpu_exclusive;
      
      sprintf(log_buf,
        "Setting gpu %s/%d to state EXCLUSIVE for job %s",
        pnode->nd_name,
        j,
        pjob->ji_qs.ji_jobid);
      
      if (LOGLEVEL >= 7)
        {
        log_ext(-1, id, log_buf, LOG_DEBUG);
        }
      }
    
    /*
     * If this a real gpu in shared/default job mode and the state is
     * unallocated then we change state to shared so only other shared jobs
     * can use it
     */
    
    if ((pnode->nd_gpus_real) && (gn->mode == gpu_normal) && 
        (gpu_mode_rqstd == gpu_normal) && (gn->state == gpu_unallocated))
      {
      gn->state = gpu_shared;
      
      sprintf(log_buf,
        "Setting gpu %s/%d to state SHARED for job %s",
        pnode->nd_name,
        j,
        pjob->ji_qs.ji_jobid);
      
      if (LOGLEVEL >= 7)
        {
        log_ext(-1, id, log_buf, LOG_DEBUG);
        }
      }
#endif  /* NVIDIA_GPUS */
    }

  return(PBSE_NONE);
  } /* END place_gpus_in_hostlist() */



/*
 * checks the subnodes of pnode and places them in the host list
 * as necessary
 */

int place_subnodes_in_hostlist(

  struct howl       **hlist,
  job                *pjob,
  short               newstate,
  struct pbsnode     *pnode,
  node_job_add_info  *naji)

  {
  struct pbssubn *snp;

  /* place the subnodes (nps) in the hostlist */
  for (snp = pnode->nd_psn; snp && naji->ppn_needed > 0; snp = snp->next)
    {
    if (exclusive)
      {
      if (snp->inuse != INUSE_FREE)
        continue;
      }
    else
      {
      if ((snp->inuse != INUSE_FREE) && (snp->inuse != INUSE_JOBSHARE))
        {
        continue;
        }
      }
    
    /* Mark subnode as being IN USE */
    add_job_to_node(pnode,snp,newstate,pjob,exclusive);
    build_host_list(hlist,snp,pnode);
    naji->ppn_needed--;
    }  /* END for (snp) */

  return(PBSE_NONE);
  } /* END place_subnodes_in_hostlist() */



/*
 * takes a struct howl and translates it to a string that will
 * become a job attribute (exec_hosts, exec_gpus, exec_ports)
 * NOTE: frees list (the struct howl)
 */

int translate_howl_to_string(

  struct howl  *list,
  char         *EMsg,
  int          *NCount,
  char        **str_ptr,
  char        **portstr_ptr,
  int           port)

  {
  static char *id = "translate_howl_to_string";
  struct howl *hp;
  struct howl *next;
  size_t       len = 1;
  int          count = 1;
  char        *str;
  char        *portlist = NULL;

  for (hp = list;hp != NULL;hp = hp->next)
    {
    len += (strlen(hp->name) + 6);
    count++;
    }

  if ((str = calloc(1, len + 1)) == NULL)
    {
    log_err(ENOMEM, id, "Cannot allocate memory!");

    if (EMsg != NULL)
      sprintf(EMsg,"no nodes can be allocated to job");
    
    return(PBSE_RESCUNAV);
    }

  *str = '\0';

  if (port == TRUE)
    {
    /* port list will have a string of sister port addresses */
    if ((portlist = calloc(1, (count * PBS_MAXPORTNUM) + count)) == NULL)
      {
      log_err(ENOMEM, id, "Cannot allocate memory!");
      
      if (EMsg != NULL)
        sprintf(EMsg,"no nodes can be allocated to job");
      
      return(PBSE_RESCUNAV);
      }
  
    *portlist = '\0';
    }

  /* now copy in name+name+... */
  *NCount = 0;

  for (hp = list; hp != NULL; hp = next)
    {
    (*NCount)++;

    sprintf(str + strlen(str), "%s/%d+",
      hp->name,
      hp->index);

    if (port == TRUE)
      sprintf(portlist + strlen(portlist), "%d+", hp->port);

    next = hp->next;

    free(hp);
    }

  /* strip trailing '+' and assign pointers */
  str[strlen(str) - 1] = '\0';
  *str_ptr = str;

  if (port == TRUE)
    {
    portlist[strlen(portlist) - 1] = '\0';
    *portstr_ptr = portlist;
    }

  return(PBSE_NONE);
  } /* END translate_howl_to_string() */




/*
 * builds the hostlist based on the nodes=... part of the request
 */

int build_hostlist_nodes_req(
    
  job                *pjob,     /* M */
  char               *EMsg,     /* O */
  char               *spec,     /* I */
  short               newstate, /* I */
  struct howl       **hlist,    /* O */
  struct howl       **gpu_list, /* O */
  node_job_add_info  *naji)     /* I */

  {
  static char       *id = "build_hostlist_nodes_req";
  struct pbsnode    *pnode = NULL;

  node_job_add_info *current;
  char               log_buf[LOCAL_LOG_BUF_SIZE];
  int                failure = FALSE;

  current = naji;

  while (current != NULL)
    {
    if ((pnode = find_nodebyname(current->node_name)) != NULL)
      {
      if (failure == TRUE)
        {
        /* just remove the marked request from the node */
        pnode->nd_np_to_be_used    -= current->ppn_needed;
        pnode->nd_ngpus_to_be_used -= current->gpu_needed;
        }
      else
        {
        place_gpus_in_hostlist(pnode, pjob, current, gpu_list);      
        place_subnodes_in_hostlist(hlist, pjob, newstate, pnode, current);

        if ((naji->gpu_needed > 0) || 
            (naji->ppn_needed > 0))
          {
          failure = TRUE;
       
          /* remove any remaining things marked on the node */
          pnode->nd_np_to_be_used    -= current->ppn_needed;
          pnode->nd_ngpus_to_be_used -= current->gpu_needed;
          }
        }

      unlock_node(pnode, id, NULL, LOGLEVEL);
      }

    current = current->next;
    } /* END processing reserved nodes */

  if (failure == TRUE)
    {
    /* did not satisfy the request */
    if (EMsg != NULL)
      {
      sprintf(log_buf,
        "could not locate requested gpu resources '%.4000s' (node_spec failed) %s",
        spec,
        EMsg);
      
      log_record(PBSEVENT_JOB,PBS_EVENTCLASS_JOB,pjob->ji_qs.ji_jobid,log_buf);
      }
    
    return(PBSE_RESCUNAV);
    }

  return(PBSE_NONE);
  } /* END build_hostlist_nodes_req() */




int build_hostlist_procs_req(

  job          *pjob,     /* M */
  int           procs,    /* I */
  short         newstate, /* I */
  struct howl **hlist)    /* O */

  {
  int             procs_needed;
  node_iterator   iter;
  struct pbsnode *pnode = NULL;
  struct pbssubn *snp;

  /* did we have a request for procs? Do those now */
  if (procs > 0)
    {
    /* check to see if a -l nodes request was made */
    if (pjob->ji_have_nodes_request)
      {
      procs_needed = procs;
      }
    else
      {
      /* the qsub request used -l procs only. No -l nodes=x
         was given in the qsub request.
         TORQUE allocates 1 node by default if a -l nodes specification
         is not given.
      */
      if (procs > 1)
        {
        procs_needed = procs - 1;
        }
      else
        procs_needed = 1;
      }
  
    reinitialize_node_iterator(&iter);

    while ((pnode = next_node(&allnodes,pnode,&iter)) != NULL)
      {
      for (snp = pnode->nd_psn;snp && procs_needed > 0;snp = snp->next)
        {
        if (exclusive)
          {
          if (snp->inuse != INUSE_FREE)
            {
            continue;
            }
          }
        else
          {
          if ((snp->inuse != INUSE_FREE) && (snp->inuse != INUSE_JOBSHARE))
            {
            continue;
            }
          }

        /* Mark subnode as being IN USE */
        pnode->nd_needed++; /* we do this because add_job_to_node will decrement it */

        /* We need to set the node to thinking. */
        pnode->nd_flag = thinking;
        add_job_to_node(pnode,snp,newstate,pjob,exclusive);

        build_host_list(hlist,snp,pnode);
        procs_needed--;
        } /* END for (snp) */
      } /* END for each node */
    } /* if (procs > 0) */

  return(PBSE_NONE);
  } /* END build_hostlist_procs_req() */


/* Free's the array */
void free_naji(node_job_add_info *naji)
  {
  node_job_add_info *current = NULL;
  node_job_add_info *tmp = NULL;
  node_job_add_info *first = naji;

  current = naji;
  while (current != NULL) 
    {
    tmp = current;
    current = current->next;
    free(tmp);
    if (current == first)
      break;
    }
  }

/*
 * set_nodes() - Call node_spec() to allocate nodes then set them inuse.
 * Build list of allocated nodes to pass back in rtnlist.
 *      Return: PBS error code
 */

int set_nodes(

  job   *pjob,        /* I */
  char  *spec,        /* I */
  int    procs,       /* I */
  char **rtnlist,     /* O */
  char **rtnportlist, /* O */
  char  *FailHost,    /* O (optional,minsize=1024) */
  char  *EMsg)        /* O (optional,minsize=1024) */

  {
  static char        id[] = "set_nodes";

  struct howl       *hlist;
  struct howl       *gpu_list;

  int                i;
  int                rc;
  int                NCount;
  short              newstate;

  char              *gpu_str = NULL;
  char               ProcBMStr[MAX_BM];
  char               log_buf[LOCAL_LOG_BUF_SIZE];
  node_job_add_info  *naji = NULL;

#ifdef NVIDIA_GPUS
  int gpu_flags = 0;
#endif  /* NVIDIA_GPUS */

  if (FailHost != NULL)
    FailHost[0] = '\0';

  if (EMsg != NULL)
    EMsg[0] = '\0';

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buf, "allocating nodes for job %s with node expression '%.4000s'",
      pjob->ji_qs.ji_jobid,
      spec);

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
    }

  ProcBMStr[0] = '\0';
#ifdef GEOMETRY_REQUESTS
  get_bitmap(pjob,sizeof(ProcBMStr),ProcBMStr);
#endif /* GEOMETRY_REQUESTS */

  naji = calloc(1, sizeof(node_job_add_info));

  /* allocate nodes */
  if ((i = node_spec(spec, 1, 1, ProcBMStr, FailHost, naji, EMsg)) == 0) /* check spec */
    {
    /* no resources located, request failed */
    if (EMsg != NULL)
      {
      sprintf(log_buf,
        "could not locate requested resources '%.4000s' (node_spec failed) %s",
        spec,
        EMsg);

      log_record(PBSEVENT_JOB,PBS_EVENTCLASS_JOB,pjob->ji_qs.ji_jobid,log_buf);
      }

    return(PBSE_RESCUNAV);
    }
  else if (i < 0)
    {
    /* request failed, corrupt request */
    log_err(PBSE_UNKNODE, id, "request failed, corrupt request");
    return(PBSE_UNKNODE);
    }

  hlist = NULL;
  gpu_list = NULL;

  newstate = exclusive ? INUSE_JOB : INUSE_JOBSHARE;

  if ((rc = build_hostlist_nodes_req(pjob, EMsg, spec, newstate, &hlist, &gpu_list, naji)) != PBSE_NONE)
    {
    free_naji(naji);
    return(rc);
    }
  free_naji(naji);

  if ((rc = build_hostlist_procs_req(pjob, procs, newstate, &hlist)) != PBSE_NONE)
    {
    return(rc);
    }

  if (hlist == NULL)
    {
    if (LOGLEVEL >= 1)
      {
      sprintf(log_buf, "no nodes can be allocated to job %s",
        pjob->ji_qs.ji_jobid);

      log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
      }

    if (EMsg != NULL)
      sprintf(EMsg, "no nodes can be allocated to job");

    return(PBSE_RESCUNAV);
    }  /* END if (hlist == NULL) */

  pjob->ji_qs.ji_svrflags |= JOB_SVFLG_HasNodes;  /* indicate has nodes */

  /* build list of allocated nodes, gpus, and ports */
  if ((rc = translate_howl_to_string(hlist, EMsg, &NCount, rtnlist, rtnportlist, TRUE)) != PBSE_NONE)
    {
    return(rc);
    }

  if (gpu_list != NULL)
    {
    if ((rc = translate_howl_to_string(gpu_list, EMsg, &NCount, &gpu_str, NULL, FALSE)) != PBSE_NONE)
      {
      return(rc);
      }

    job_attr_def[JOB_ATR_exec_gpus].at_free(
      &pjob->ji_wattr[JOB_ATR_exec_gpus]);
    
    job_attr_def[JOB_ATR_exec_gpus].at_decode(
      &pjob->ji_wattr[JOB_ATR_exec_gpus],
      NULL,
      NULL,
      gpu_str,
      0);  /* O */
    
    free(gpu_str);

#ifdef NVIDIA_GPUS
    if (gpu_mode_rqstd != -1)
      gpu_flags = gpu_mode_rqstd;
    if (gpu_err_reset)
      gpu_flags += 1000;

    if (gpu_flags >= 0)
      {
      pjob->ji_wattr[JOB_ATR_gpu_flags].at_val.at_long = gpu_flags;
      pjob->ji_wattr[JOB_ATR_gpu_flags].at_flags = ATR_VFLAG_SET | ATR_VFLAG_MODIFY;
      
      if (LOGLEVEL >= 7)
	      {
        sprintf(log_buf, "setting gpu_flags for job %s to %d %ld",
          pjob->ji_qs.ji_jobid,
          gpu_flags,
          pjob->ji_wattr[JOB_ATR_gpu_flags].at_val.at_long);

  		  log_ext(-1, id, log_buf, LOG_DEBUG);
	      }
/*      job_save(pjob,SAVEJOB_FULL,0); */
      }
#endif  /* NVIDIA_GPUS */
    }

  if (LOGLEVEL >= 3)
    {
    snprintf(log_buf, sizeof(log_buf), "job %s allocated %d nodes (nodelist=%.4000s)",
      pjob->ji_qs.ji_jobid,
      NCount,
      *rtnlist);

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
    }

  /* SUCCESS */

  return(PBSE_NONE);
  }  /* END set_nodes() */


/* count the number of requested processors in a node spec
 * return processors requested on success
 * return -1 on error 
 */ 
int procs_requested(
    
  char *spec)

  {
  char *id = "procs_requested";
  char *str, *globs, *cp, *hold;
  int num_nodes = 0, num_procs = 0, total_procs = 0, num_gpus = 0;
  int i;
  static char shared[] = "shared";
  struct prop *prop = NULL;
  char *tmp_spec;
  char  log_buf[LOCAL_LOG_BUF_SIZE];

  tmp_spec = strdup(spec);  
  
  if (tmp_spec == NULL)
    {
    /* FAILURE */

    sprintf(log_buf,"cannot alloc memory");

    if (LOGLEVEL >= 1)
      {
      log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
      }

    return(-1);
    }

  /* Check to see if we have a global modifier */
  if ((globs = strchr(tmp_spec, '#')) != NULL)
    {
    *globs++ = '\0';

    globs = strdup(globs);

    while ((cp = strrchr(globs, '#')) != NULL)
      {
      *cp++ = '\0';

      if (strcmp(cp, shared) != 0)
        {
        hold = mod_spec(spec, cp);

        free(tmp_spec);

        tmp_spec = hold;
        }
      else
        {
        exclusive = 0;
        }
      }

    if (strcmp(globs, shared) != 0)
      {
      hold = mod_spec(tmp_spec, globs);

      free(tmp_spec);

      tmp_spec = hold;
      }
    else
      {
      exclusive = 0;
      }

    free(globs);
    }  /* END if ((globs = strchr(spec,'#')) != NULL) */

  str = tmp_spec;

  do
    {
    if ((i = number(&str, &num_nodes)) == -1 )
      {
      /* Bad string syntax. Fail */
      return(-1);
      }

    if (i == 0)
      {
      /* number exists */
      if (*str == ':')
        {
        /* there are properties */

        str++;

        if (proplist(&str, &prop, &num_procs, &num_gpus))
          {
          return(-1);
          }
        }
      }
    else
      {
      /* no number */
      num_nodes = 1;
      if (proplist(&str, &prop, &num_procs, &num_gpus))
        {
        /* must be a prop list with no number in front */

        return(-1);
        }
      }
    total_procs += num_procs * num_nodes;
    } while(*str++ == '+');
  
  free(tmp_spec);
  
  return(total_procs);
  } /* END procs_requested() */





/*
 * node_avail_complex -
 * *navail is set to number available
 * *nalloc is set to number allocated
 * *nresvd is set to number reserved
 * *ndown  is set to number down/offline
 *      return -1 on failure
 */

int node_avail_complex(

  char *spec,  /* I - node spec */
  int  *navail, /* O - number available */
  int *nalloc, /* O - number allocated */
  int *nresvd, /* O - number reserved  */
  int *ndown)  /* O - number down      */

  {
  int ret;

  ret = node_spec(spec, 1, 0, NULL, NULL, NULL, NULL);

  *navail = ret;
  *nalloc = 0;
  *nresvd = 0;
  *ndown  = 0;

  return(ret);
  }  /* END node_avail_complex() */





/*
 * node_avail - report if nodes requested are available
 * Does NOT even consider Time Shared Nodes
 *
 * Return 0 when no error in request and
 *  *navail is set to number available
 *  *nalloc is set to number allocated
 *  *nresvd is set to number reserved
 *  *ndown  is set to number down/offline
 *      !=0 error number when error in request
 */

int node_avail(

  char *spec,  /* I  - node spec */
  int  *navail, /* O - number available */
  int *nalloc, /* O - number allocated */
  int *nresvd, /* O - number reserved  */
  int *ndown)  /* O - number down      */

  {
  char *id = "node_avail";
  int j;
  int holdnum;

  struct pbsnode *pn;

  struct  pbssubn *psn;
  char    *pc;

  struct prop *prop = NULL;
  register int xavail;
  register int xalloc;
  register int xresvd;
  register int xdown;
  int          node_req = 1;
  int          gpu_req = 0;

  node_iterator iter;

  if (spec == NULL)
    {
    log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, "no spec");

    return(RM_ERR_NOPARAM);
    }

  pc = spec;

  if ((strchr(spec, (int)'+') == NULL) && (number(&pc, &holdnum) == 1))
    {
    /* A simple node spec - reply with numbers of avaiable, */
    /* allocated, reserved, and down nodes that match the */
    /* the spec, null or simple number means all  */

    xavail = 0;
    xalloc = 0;
    xresvd = 0;
    xdown  = 0;

    /* find number of a specific type of node */

    if (*pc)
      {
      if (proplist(&pc, &prop, &node_req, &gpu_req))
        {
        return(RM_ERR_BADPARAM);
        }
      }

    reinitialize_node_iterator(&iter);
    pn = NULL;

    while ((pn = next_node(&allnodes, pn, &iter)) != NULL)
      {
      if ((pn->nd_ntype == NTYPE_CLUSTER) && hasprop(pn, prop))
        {
        if (pn->nd_state & (INUSE_OFFLINE | INUSE_DOWN))
          ++xdown;
        else if (hasppn(pn, node_req, SKIP_ANYINUSE))
          ++xavail;
        else if (hasppn(pn, node_req, SKIP_NONE))
          {
          /* node has enough processors, are they busy or reserved? */
          j = 0;
          
          for (psn = pn->nd_psn;psn;psn = psn->next)
            {
            if (psn->inuse & INUSE_RESERVE)
              j++;
            }
          
          if (j >= node_req)
            ++xresvd;
          else
            ++xalloc;
          }
        }
      } /* END for each node */

    free_prop(prop);

    *navail = xavail;

    *nalloc = xalloc;

    *nresvd = xresvd;

    *ndown  = xdown;

    return(0);
    }
  else if (number(&pc, &holdnum) == -1)
    {
    /* invalid spec */

    return(RM_ERR_BADPARAM);
    }

  /* not a simple spec - determine if supplied complex */
  /* node spec can be satisified from avail nodes */
  /* navail set to >0 if can be satified now  */
  /*    0 if not now but possible  */
  /*   -l if never possible   */

  node_avail_complex(spec, navail, nalloc, nresvd, ndown);

  return(0);
  }  /* END node_avail() */




/*
 * node_reserve - Reserve nodes
 * Cannot reserve Time Shared Nodes
 *
 * Returns: >0 - reservation succeeded, number of nodes reserved
 *    0 - None or partial reservation
 *   -1 - requested reservation impossible
 */

int node_reserve(

  char       *nspec, /* In     - a node specification */
  resource_t  tag)   /* In/Out - tag for resource if reserved */

  {
  static char        id[] = "node_reserve";
  int                nrd;

  struct pbsnode    *pnode;

  struct pbssubn    *snp;
  int                ret_val;

  node_iterator      iter;
  char               log_buf[LOCAL_LOG_BUF_SIZE];
  node_job_add_info  *naji = NULL;

  DBPRT(("%s: entered\n",
         id))

  if ((nspec == NULL) || (*nspec == '\0'))
    {
    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      id,
      "no spec");

    return(-1);
    }

  naji = calloc(1, sizeof(node_job_add_info));

  if ((ret_val = node_spec(nspec, 0, 0, NULL, NULL, naji, NULL)) >= 0)
    {
    /*
    ** Zero or more of the needed Nodes are available to be
    ** reserved.
    */
    reinitialize_node_iterator(&iter);
    pnode = NULL;

    while ((pnode = next_node(&allnodes,pnode,&iter)) != NULL)
      {
      if (pnode->nd_flag != thinking)
        {
        continue;   /* skip this one */
        }

      nrd = 0;

      for (snp = pnode->nd_psn;snp && pnode->nd_needed;snp = snp->next)
        {
        if (snp->inuse == INUSE_FREE)
          {
          DBPRT(("hold %s/%d\n",
                 pnode->nd_name,
                 snp->index))

          snp->inuse |= INUSE_RESERVE;
          snp->allocto = tag;

          pnode->nd_nsnfree--;  /* in reserve, not reached? */

          --pnode->nd_needed;

          ++nrd;
          }
        }

      if (nrd == pnode->nd_nsn)
        pnode->nd_state = INUSE_RESERVE;
      } /* END for each node */
    }
  else
    {
    /* could never satisfy the reservation */

    snprintf(log_buf, sizeof(log_buf), "can never reserve %s", nspec);

    log_record(PBSEVENT_SCHED,PBS_EVENTCLASS_REQUEST,id,log_buf);
    }
  free_naji(naji);

  return(ret_val);
  }  /* END node_reserve() */






/*
 * is_ts_node - does the nodestr specify a single time share node?
 * 0 - yes
 * 1 - no, not a ts node or more than one node (name will not match)
 */

int is_ts_node(

  char *nodestr)

  {
  int             rc = 1; /* see comment above */
  struct pbsnode *np = find_nodebyname(nodestr);

  if (np != NULL)
    {
    if (np->nd_ntype == NTYPE_TIMESHARED)
      {
      rc = 0;
      }

    unlock_node(np, "is_ts_node", NULL, LOGLEVEL);
    }

  return(rc);
  }  /* END is_ts_node() */





/*
 * find_ts_node - find first up time-shared node
 *
 * returns name of node or null
 */

char *find_ts_node(void)

  {
  struct pbsnode *np = NULL;
  node_iterator   iter;

  reinitialize_node_iterator(&iter);

  while ((np = next_node(&allnodes,np,&iter)) != NULL)
    {
    if ((np->nd_ntype == NTYPE_TIMESHARED) &&
        ((np->nd_state & (INUSE_DOWN | INUSE_OFFLINE)) == 0))
      {
      char *name = np->nd_name;

      unlock_node(np, "find_ts_node", NULL, LOGLEVEL);

      return(name);
      }
    } /* END for each node */

  return(NULL);
  }  /* END find_ts_node() */





/*
 * free_nodes - free nodes allocated to a job
 */

void free_nodes(

  job *pjob)  /* I (modified) */

  {
  static char id[] = "free_nodes";

  struct pbssubn *np;

  struct pbsnode *pnode;

  struct jobinfo *jp;
  struct jobinfo *prev;
  char            log_buf[LOCAL_LOG_BUF_SIZE];

  int             i;
  char           *gpu_str = NULL;
#ifdef NVIDIA_GPUS
  char            tmp_str[PBS_MAXHOSTNAME + 10];
  char            num_str[6];
#endif  /* NVIDIA_GPUS */

  node_iterator iter;

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buf, "freeing nodes for job %s", pjob->ji_qs.ji_jobid);

    log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buf);
    }

  if ((pjob->ji_wattr[JOB_ATR_exec_gpus].at_flags & ATR_VFLAG_SET) != 0)
    {
    gpu_str = pjob->ji_wattr[JOB_ATR_exec_gpus].at_val.at_str;
    }

  /* examine all nodes in cluster */
  reinitialize_node_iterator(&iter);
  pnode = NULL;

  while ((pnode = next_node(&allnodes,pnode,&iter)) != NULL)
    {
    if (gpu_str != NULL)
      {
      /* reset gpu nodes */
      for (i = 0; i < pnode->nd_ngpus; i++)
        {
        struct gpusubn *gn = pnode->nd_gpusn + i;
#ifdef NVIDIA_GPUS
        if (pnode->nd_gpus_real)
          {
          /* reset real gpu nodes */
          strcpy (tmp_str, pnode->nd_name);
          strcat (tmp_str, "-gpu/");
          sprintf (num_str, "%d", i);
          strcat (tmp_str, num_str);

          /* look thru the string and see if it has this host and gpuid.
           * exec_gpus string should be in format of 
           * <hostname>-gpu/<index>[+<hostname>-gpu/<index>...]
           *
           * if we are using the gpu node exclusively or if shared mode and
           * this is last job assigned to this gpu then set it's state
           * unallocated so its available for a new job. Takes time to get the
           * gpu status report from the moms.
           */

          if (strstr (gpu_str, tmp_str) != NULL)
            {
            if ((gn->mode == gpu_exclusive_thread) ||
                 (gn->mode == gpu_exclusive_process) ||
                 ((gn->mode == gpu_normal) && 
                 (count_gpu_jobs(pnode->nd_name, i) == 0)))
              {
              gn->state = gpu_unallocated;

              if (LOGLEVEL >= 7)
                {
                sprintf(log_buf, "freeing node %s gpu %d for job %s",
                  pnode->nd_name,
                  i,
                  pjob->ji_qs.ji_jobid);

                log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buf);
                }

              }
            }
          }
        else
#endif  /* NVIDIA_GPUS */
          {
          if (!strcmp(gn->jobid, pjob->ji_qs.ji_jobid))
            {
            gn->inuse = FALSE;
            memset(gn->jobid, 0, sizeof(gn->jobid));

            pnode->nd_ngpus_free++;
            }
          }
        }
      }

    /* examine all subnodes in node */
    for (np = pnode->nd_psn;np != NULL;np = np->next)
      {
      /* examine all jobs allocated to subnode */

      for (prev = NULL, jp = np->jobs;jp != NULL;prev = jp, jp = jp->next)
        {
        if (strcmp(jp->jobid, pjob->ji_qs.ji_jobid))
          continue;

        if (LOGLEVEL >= 4)
          {
          sprintf(log_buf, "freeing node %s/%d from job %s (nsnfree=%d)",
            pnode->nd_name,
            np->index,
            pjob->ji_qs.ji_jobid,
            pnode->nd_nsnfree);

          log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buf);
          }

        if (prev == NULL)
          np->jobs = jp->next;
        else
          prev->next = jp->next;

        free(jp);

        pnode->nd_nsnfree++; /* up count of free */

        if (LOGLEVEL >= 6)
          {
          sprintf(log_buf, "increased sub-node free count to %d of %d\n",
            pnode->nd_nsnfree,
            pnode->nd_nsn);

          log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buf);
          }

        pnode->nd_state &= ~(INUSE_JOB | INUSE_JOBSHARE);

        /* if no jobs are associated with subnode, mark subnode as free */

        if (np->jobs == NULL)
          {
          if (np->inuse & INUSE_JOBSHARE)
            pnode->nd_nsnshared--;

          /* adjust node state (turn off job/job-exclusive) */

          np->inuse &= ~(INUSE_JOB | INUSE_JOBSHARE);
          }

        break;
        }  /* END for (prev) */
      }    /* END for (np) */
    } /* END for each node */

  pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_HasNodes;

  return;
  }  /* END free_nodes() */





/*
 * set_one_old - set a named node as allocated to a job
 */

static void set_one_old(

  char *name,
  job  *pjob,
  int   shared) /* how used flag, either INUSE_JOB or INUSE_JOBSHARE */

  {
  int             index;

  struct pbsnode *pnode;

  struct pbssubn *snp;

  struct jobinfo *jp;
  char           *pc;

  if ((pc = strchr(name, (int)'/')))
    {
    index = atoi(pc + 1);

    *pc = '\0';
    }
  else
    {
    index = 0;
    }

  pnode = find_nodebyname(name);

  if (pnode != NULL)
    {
    /* Mark node as being IN USE ...  */
    if (pnode->nd_ntype == NTYPE_CLUSTER)
      {
      for (snp = pnode->nd_psn;snp;snp = snp->next)
        {
        if (snp->index == index)
          {
          snp->inuse = shared;
          
          jp = (struct jobinfo *)calloc(1, sizeof(struct jobinfo));
          
          /* NOTE:  should report failure if jp == NULL (NYI) */
          if (jp != NULL)
            {
            jp->next = snp->jobs;
            
            snp->jobs = jp;
            
            strcpy(jp->jobid, pjob->ji_qs.ji_jobid);
            }
          
          if (--pnode->nd_nsnfree <= 0)
            pnode->nd_state |= shared;
         
          break;
          }
        }    /* END for (snp) */
      }

    unlock_node(pnode, __func__, NULL, LOGLEVEL);
    }

  return;
  }  /* END set_one_old() */





/*
 * set_old_nodes - set "old" nodes as in use - called from pbsd_init()
 * when recovering a job in the running state.
 */

void set_old_nodes(

  job *pjob)  /* I (modified) */

  {
  char *old;
  char *po;
  resource *presc;
  int   shared = INUSE_JOB;

  if (pjob->ji_wattr[JOB_ATR_exec_host].at_flags & ATR_VFLAG_SET)
    {
    /* are the nodes being used shared? Look in "neednodes" */

    presc = find_resc_entry(
              &pjob->ji_wattr[JOB_ATR_resource],
              find_resc_def(svr_resc_def, "neednodes", svr_resc_size));

    if ((presc != NULL) && (presc->rs_value.at_flags & ATR_VFLAG_SET))
      {
      if ((po = strchr(presc->rs_value.at_val.at_str, '#')))
        {
        if (strstr(++po, "shared") != NULL)
          shared = INUSE_JOBSHARE;
        }
      }

    old = strdup(pjob->ji_wattr[JOB_ATR_exec_host].at_val.at_str);

    if (old == NULL)
      {
      /* FAILURE - cannot alloc memory */

      return;
      }

    while ((po = strrchr(old, (int)'+')) != NULL)
      {
      *po++ = '\0';

      set_one_old(po, pjob, shared);
      }

    set_one_old(old, pjob, shared);

    free(old);
    }  /* END if pjobs exec host is set */

  return;
  }  /* END set_old_nodes() */

  
job *get_job_from_jobinfo(
    
  struct jobinfo *jp,
  struct pbsnode *pnode)
  
  {
  job *pjob;

  unlock_node(pnode, __func__, NULL, LOGLEVEL);
  pjob = find_job(jp->jobid);
  lock_node(pnode, __func__, NULL, LOGLEVEL);

  return(pjob);
  } /* END get_job_from_jobinfo() */


/* END node_manager.c */

